<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NingLab</title>
  
  
  <link href="http://ninglab.com/atom.xml" rel="self"/>
  
  <link href="http://ninglab.com/"/>
  <updated>2024-05-19T10:42:12.842Z</updated>
  <id>http://ninglab.com/</id>
  
  <author>
    <name>Ning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django - 基礎 models 概念與關聯</title>
    <link href="http://ninglab.com/Django-models-1/"/>
    <id>http://ninglab.com/Django-models-1/</id>
    <published>2024-05-19T10:24:05.000Z</published>
    <updated>2024-05-19T10:42:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-Models"><a href="#Django-Models" class="headerlink" title="Django - Models"></a>Django - Models</h1><p>Django 所採用的模式是 MTV 模式</p><p>上週介紹的 Views 文章有提到 MTV 模式，我們再來複習一下</p><p>使用者瀏覽網頁時，伺服器的運作流程如下：</p><p><img src="https://imgur.com/wg4bxVE.jpg" alt="MTV"></p><p>urls.py 會將 request 傳送至 View</p><p>View 收到 request，處理過程中需要資料庫的資料時，就會向 Model 要資料</p><p>Model 收到 View 來的指令，將處理好的資料給 View (* Model 不是代表資料庫，而是 負責與資料庫溝通 的一個 Layer )</p><p>View 收到資料後，將資料做最後的處理</p><p>View 拿 Template 的東西來進行 render，最後由 View 回應給使用者</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>我們這週要來介紹的是 Model</p><p>當我們需要處理資料時，就會需要 Model</p><p>Model 並不是只資料庫，而是跟資料庫溝通的一層 Layer</p><p>我們先來了解什麼是 <code>ORM</code></p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>Django 採用 ORM 來處理資料，ORM 全名為 <code>Object Relational Mapping</code> ，</p><p>原本我們要使用 SQL 語法 跟資料庫溝通</p><p>不過 ORM 讓我們可以用 <code>物件</code> 的方式來處理資料</p><p>假設我想看某個 table 的所有資料</p><p>我必須要用 SQL 語法來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name;</span><br></pre></td></tr></table></figure><p>但如果是用 Django 的 ORM 語法呢？會簡單易懂許多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.objects.all()</span><br></pre></td></tr></table></figure><p>了解了 ORM 語法後，我們可以先來看一下該怎麼定義 table 以及 column</p><h2 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h2><p>我們會將要定義的 table 以及 column 放在 models.py 這個檔案之中</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p>在 Django 的手冊中指出，每個 model 都是 class，因此可以繼承 django.db.models.Model 的特性</p><blockquote><p>Each model is a Python class that subclasses django.db.models.Model</p></blockquote><p>所以第一件事就是用 <code>class</code> 的方式定義 <code>table</code></p><p>並在該 class 中定義屬性，這些屬性代表 <code>table</code> 中的 <code>column</code> ，在 Django 稱作為 field</p><blockquote><p>Each field is specified as a class attribute, and each attribute maps to a database column.</p></blockquote><p>我們要先 import <code>models</code>，讓 class 去繼承 models 中的 Model</p><p>接著定義 table 的名稱以及屬性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=20, default=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>理解基本的 table 以及 column 定義後，我們可以來點關聯！</p><h3 id="one-to-one"><a href="#one-to-one" class="headerlink" title="one to one"></a>one to one</h3><p>有些資料會有一對一的關聯，舉例來說</p><p>除了基本 User 資料，需要有另一個 Model 來存個人資訊，像是 地址 &#x2F; mail &#x2F; 電話等等</p><p>這時候 User 與個人資料 table 就會有一對一的關聯</p><p>該怎麼做呢？</p><h4 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>當我們知道一個 User 會有一個 Profile 之後，</p><p>就可以用 <code>關係</code> 來想看看 <code>ForeignKey</code> 設定該放在哪裡</p><p>通常我們會將 Foreign Key 放置在「屬於」的 Model 中</p><p>以剛剛的例子來說，是 Profile 會 <code>屬於</code> 一個 User</p><p>所以我們會將 <code>ForeignKey</code> 放在 <code>Profile</code> 該 table 中</p><p>ForeignKey 就像是一條線索， Profile 會透過該線索，去找到 User</p><p><img src="https://imgur.com/6CSSwpF.jpg" alt="one to one"></p><p>接著我們就來把它轉變成程式碼吧！</p><p>在 ForeignKey 中有幾個必填的參數</p><blockquote><p>class ForeignKey(to, on_delete, **options)</p></blockquote><p>第一個參數是 ForeignKey 會指向哪個 model</p><p>第二個參數 on_delete 意思是當 <code>關聯 model</code> 的資料被刪除時，要做什麼事，這邊我們設定成 models.CASCADE ，代表當 User 被刪除時，跟該筆有關的 Profile 都會被刪除</p><p>第三個參數是為了一對一的關聯而設定的，我們希望一筆 User 只對應一筆 Profile ，對於 Profile 來說，每一個 User 的 id 都是獨特的，不可重複</p><p>(如果沒有設定這個參數，那就會變成 User 可以有多筆 Profile 囉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE, unique=True)</span><br></pre></td></tr></table></figure><h4 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h4><p>Django 也有提供更明確的一對一關聯方法，</p><p>也就是 OneToOneField</p><p>這個方法會會直接在 Profile 中增加一個欄位，存放 Foreign Key (也就是 User 的 id )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    email = models.CharField(max_length=10, default=&quot;&quot;)</span><br><span class="line">    address = models.CharField(max_length=50, default=&quot;&quot;)</span><br><span class="line">    phone = models.CharField(max_length=10, default=&quot;&quot;)</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>上述兩種方法都可以建立一對一的關聯，</p><p>相較於 <code>ForeignKey</code> 的方式，<code>OneToOneField</code> 在程式碼中會顯得更易讀明確</p><h3 id="many-to-one"><a href="#many-to-one" class="headerlink" title="many to one"></a>many to one</h3><p>再來就是稍微複雜的關聯，多對一，</p><p>舉例來說，今天一個 User 會有多筆 Order</p><p>但一筆 Order 只能對應一個 User</p><p>這時候就會形成 <code>多對一</code> 的關聯</p><p>我們來看一下該怎麼設定</p><h4 id="ForeignKey-1"><a href="#ForeignKey-1" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>就像剛剛舉例的，我們會將 <code>Foreign Key</code> 放在 「屬於」 的 table </p><p>這次的例子是 多筆 Order 會屬於一個 User</p><p>所以我們會將 <code>ForeignKey</code> 該設定放在 Order 中</p><p>我們直接用圖片來理解比較快</p><p><img src="https://imgur.com/NR6Jwsv.jpg" alt="many to one"></p><p>理解了多對一的關係後，我們就可以來轉變成程式碼了</p><p>跟剛剛的一對一不同，這時每個 Order 的 User 是可以重複的，所以我們不需要加上 <code>unique=True</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">class Order(models.Model):</span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><h3 id="many-to-many"><a href="#many-to-many" class="headerlink" title="many to many"></a>many to many</h3><p>再來就會更複雜一點，也就是多對多的關聯</p><p>舉例來說，使用者與群組的關聯，</p><p>一個使用者可以參加多個群組，</p><p>而一個群組可以擁有多個使用者，</p><p>這時候就會形成多對多的關聯</p><p><img src="https://imgur.com/NWvEUxd.jpg" alt="many to many"></p><h4 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h4><p>Django 提供了我們 ManyToManyField 的方法</p><p>這次的關係是 一個使用者可以 <code>屬於</code> 多個群組 且 一個群組可以 <code>屬於</code> 多個使用者</p><p>不過通常多對多的關係，都會用第三方表格來存放雙方的關聯</p><p>所以 <code>ForeignKey</code> 會放在第三方表格中</p><p>而 User 及 Group 則是要設定 <code>ManyToManyField</code> 以及 through 參數，</p><p>當你需要用 User 去查詢 Group 的時候就會比較方便，不需要透過第三方表格</p><ul><li>屬性的定義 是要用複數，不然會跑出提醒你要改名的錯誤訊息</li><li>User 在建立的時候，Group 還不存在，因此要用字串來取代</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">  groups = models.ManyToManyField(&#x27;Group&#x27;, through=&quot;UserGroup&quot;)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line">  users = models.ManyToManyField(User, through=&quot;UserGroup&quot;)</span><br><span class="line">  </span><br><span class="line">class UserGroup(models.Model):</span><br><span class="line">  user = models.ForeignKey(User, on_delete=models.CASCADE)</span><br><span class="line">  group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>雖然多對多的關係可以在第三方表格用 <code>ForeignKey</code> 來設定關聯，</p><p>但如果沒有透過 <code>ManyToManyField</code></p><p>在查找資料的時候就都得透過第三方表格，其實蠻不方便的</p><p>所以還是要設定 <code>ManyToManyField</code> 以及 <code>through</code> 參數唷</p><p>基本的關聯差不多都介紹完了，接下來就剩怎麼將定義變成資料庫中的 table 以及 column</p><h3 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h3><p>當我們將 table 及 column 都設定好之後，就可以來做 migration 啦</p><p>migration 是什麼呢？</p><p>我們可以把它想像成是 Database 的歷史紀錄</p><p>有任何的更動都會被記錄在 migration 中</p><p>在 Django 中，我們只要下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><p>就會依照更動來做出新的 migration 囉</p><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><p>當 migration 做完，我們就該來改變資料庫的 table 以及 column</p><p>這時候就需要下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>資料庫這時候就會依據設定改變了</p><h4 id="狀況題：如果-migrate-之後，又要做更動該怎麼辦？"><a href="#狀況題：如果-migrate-之後，又要做更動該怎麼辦？" class="headerlink" title="狀況題：如果 migrate 之後，又要做更動該怎麼辦？"></a>狀況題：如果 migrate 之後，又要做更動該怎麼辦？</h4><p>只要動到 models 這個檔案，再重新做一次 makemigrations 再 migrate 就可以了</p><h4 id="狀況題：如果需要更改-migration-的時候該怎麼辦"><a href="#狀況題：如果需要更改-migration-的時候該怎麼辦" class="headerlink" title="狀況題：如果需要更改 migration 的時候該怎麼辦"></a>狀況題：如果需要更改 migration 的時候該怎麼辦</h4><p>在 Django 中，有可以讓我們 rollback 的指令</p><p>什麼是 rollback 呢？可以把它想像成是鍵盤的 ctrl + z 復原鍵</p><p>我們要將 migration 復原可以下該指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate YOUR-APP-NAME YOUR-ROLLBACK-MIGRATION-NUMBER</span><br></pre></td></tr></table></figure><p>這時候就可以進行復原</p><p>以上是基礎的 Django model 使用介紹</p><p>如果還有狀況題想要提出討論，歡迎在底下留言，會傳送到我的 github 作為 issue 通知我，屆時可以一起討論</p><p>如果有幫助的話也歡迎按讚 ヾ(<em>´∀ ˋ</em>)ﾉ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Django-Models&quot;&gt;&lt;a href=&quot;#Django-Models&quot; class=&quot;headerlink&quot; title=&quot;Django - Models&quot;&gt;&lt;/a&gt;Django - Models&lt;/h1&gt;&lt;p&gt;Django 所採用的模式是 MTV 模式&lt;</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - views 的職責與方式</title>
    <link href="http://ninglab.com/Django-views/"/>
    <id>http://ninglab.com/Django-views/</id>
    <published>2024-05-12T09:58:34.000Z</published>
    <updated>2024-05-12T13:34:39.508Z</updated>
    
    <content type="html"><![CDATA[<p>提到 Views 之前，我們先來認識 MTV 架構</p><p>Django 所採用的模式是 MTV 模式</p><p>使用者瀏覽網頁時，伺服器的運作流程如下：</p><ol><li><p>urls.py 會將 request 傳送至 View</p></li><li><p>View 收到 request，處理過程中需要資料庫的資料時，就會向 Model 要資料</p></li><li><p>Model 收到 View 來的指令，將處理好的資料給 View (* Model 不是代表資料庫，而是 <code>負責與資料庫溝通</code> 的一個 Layer )</p></li><li><p>View 收到資料後，將資料做最後的處理</p></li><li><p>View 拿 Template 的東西來進行 render，最後由 View 回應給使用者</p></li></ol><p>對於 Django 的 MTV 架構有一點概念後，我們就來看看 <code>views</code> 吧！</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>我們需要做一個路徑來給 views ，好讓 Django 收到需求之後，知道該去哪裡</p><p>來看看下方例子：</p><p>我們在 url 定義了一個路徑 <code>users/</code> </p><p>這表示，當使用者進入到該路徑時，會去找 views 的 index 方法</p><p>url 不熟的話歡迎參閱 <a href="https://ninglab.com/Django-urls-1/">Django - URLS 的那些基礎用法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># user/url.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在這之前，我們要先去 views 中建立名為 <code>index</code> 的方法，讓 request 過來的時候可以提供需要的資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>對於 <code>templates</code> 到 <code>views</code> 有概念後，我們就可以再深入來看看 <code>views</code></p><h3 id="views-的職責-Request-and-Response"><a href="#views-的職責-Request-and-Response" class="headerlink" title="views 的職責 - Request and Response"></a>views 的職責 - Request and Response</h3><p>views 是一種 Function ，負責接受 request ，並且回傳 response</p><p>回傳的格式可以是 html &#x2F; xml 或者是 image </p><p>頁面收到 request 時， Django 會將建立一個 <code>HttpRequest 物件</code>，會包含 request 中的 <code>metadata 資料</code></p><p>HttpRequest 會作為<code>第一個參數</code>傳遞至對應的 views 中</p><p>剛剛提到的 <code>index</code> 例子</p><p>該引數的 request 就是 HttpRequest 物件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>當 views 處理好資料後，<code>必須</code> 要傳遞一個 HttpResponse 物件回去</p><p>以 <code>index</code> 例子來說，我們是回傳一個 render 方法回去</p><p>讓我們來看一下 render 這個方法</p><p>他會將參數變成一包 <code>HttpResponse 物件</code>，並且回傳</p><blockquote><p>Combines a given template with a given context dictionary and returns an HttpResponse object with that rendered text.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>了解 views 的職責後，我們就來看一下方式</p><h2 id="views"><a href="#views" class="headerlink" title="views"></a>views</h2><p>在 Django 中， views 可以用兩種方式來做</p><p>第一種是 <code>Function-based views</code> </p><p>第二種是 <code>Class-based views</code> </p><p>在專案中，你可以同時使用 Function-based views 或者是 Class-based views </p><p>取決於程式碼以及需求</p><h2 id="Function-based-views"><a href="#Function-based-views" class="headerlink" title="Function-based views"></a>Function-based views</h2><p>Django 預設的 views 方式，也就是 <code>一般的 Function</code>，相較於 <code>Class-based views</code> 更簡單好寫且好閱讀</p><p>也因為簡單，通常會應用在靜態頁面中</p><p>以上方程式碼的例子來說，就是一種 <code>Function-based views</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><h2 id="Class-based-views"><a href="#Class-based-views" class="headerlink" title="Class-based views"></a>Class-based views</h2><p>隨著專案日益龐大，如果這時候還是使用 <code>Function-based views</code> 會有不好擴充，以及重複程式碼的缺點</p><p><code>Class-based views</code> 就是為了解決這個問題而產生的</p><p>就以 edit 頁面來看好了，當我們使用 <code>Function-based views</code> 的話會像這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def edit(request, id=None):</span><br><span class="line">    user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = UserForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            user.name = form.cleaned_data[&quot;name&quot;]</span><br><span class="line">            user.age = form.cleaned_data[&quot;age&quot;]</span><br><span class="line">            user.email = form.cleaned_data[&quot;email&quot;]</span><br><span class="line">            user.address = form.cleaned_data[&quot;address&quot;]</span><br><span class="line">            user.phone = form.cleaned_data[&quot;phone&quot;]</span><br><span class="line"></span><br><span class="line">            user.save()</span><br><span class="line"></span><br><span class="line">            return redirect(&quot;show&quot;, id=id)</span><br><span class="line">    else:</span><br><span class="line">        form = UserForm(user.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return render(request, &quot;edit.html&quot;, &#123;&quot;form&quot;: form, &quot;user&quot;: user&#125;)</span><br></pre></td></tr></table></figure><p>但如果用 <code>CBV ( Class-based views )</code> 呢？</p><p>views 就會變成這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class UserUpdateView(UpdateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;edit.html&#x27;</span><br><span class="line"></span><br><span class="line">    def get_object(self, queryset=None):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>這時候我們需要去改變 <code>urls.py</code> 中的設定</p><p>會用到 UserUpdateView 的 <code>as_view 類別方法</code> 來呼叫 UserUpdateView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line">from .views import (UserUpdateView)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;int:id&gt;/edit/&#x27;, UserUpdateView.as_view(), name=&quot;edit&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>程式碼變得非常乾淨簡潔，如果需要哪些設定就再加上去就好了</p><h3 id="Django-中的-CBV"><a href="#Django-中的-CBV" class="headerlink" title="Django 中的 CBV"></a>Django 中的 CBV</h3><p>Django 有提供很多 CBV</p><p>以下就用 CRUD 來舉例</p><h4 id="CreateView"><a href="#CreateView" class="headerlink" title="CreateView"></a>CreateView</h4><p>會產生一個新建資料的 Form 表單</p><p>我們用一般的 <code>Function-based views</code> 會這樣寫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def new(request):</span><br><span class="line">    form = UserForm()</span><br><span class="line">    return render(request, &quot;new.html&quot;, &#123;&quot;form&quot;: form&#125;)</span><br></pre></td></tr></table></figure><p>但改成 <code>CBV</code> 就會變這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class UserCreateView(CreateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;new.html&#x27;</span><br><span class="line">    success_url = &#x27;index&#x27;</span><br></pre></td></tr></table></figure><p>個人覺得原本的 <code>Function-based views</code> 已經蠻簡潔了，所以也不一定要改成 <code>Class based views</code> 的方式</p><ul><li><code>model</code> 是指要 create 哪個 model 的資料</li><li><code>fields</code> 是只有哪些欄位需要填寫</li><li><code>template_name</code> 是要渲染在哪個 template 中</li><li><code>success_url</code> 是讓你可以設定成功會導去的路徑，但如果在 model 有設定 <code>get_absolute_url() </code> 就不需要再設定這個， Django 會直接去抓 <code>get_absolute_url() </code> 的設定</li></ul><h4 id="UpdateView"><a href="#UpdateView" class="headerlink" title="UpdateView"></a>UpdateView</h4><p>會渲染已有資料的表單，前提是要提供參數去找出資料</p><p>使用 <code>Function-based views</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def edit(request, id=None):</span><br><span class="line">    user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = UserForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            user.name = form.cleaned_data[&quot;name&quot;]</span><br><span class="line">            user.age = form.cleaned_data[&quot;age&quot;]</span><br><span class="line">            user.email = form.cleaned_data[&quot;email&quot;]</span><br><span class="line">            user.address = form.cleaned_data[&quot;address&quot;]</span><br><span class="line">            user.phone = form.cleaned_data[&quot;phone&quot;]</span><br><span class="line"></span><br><span class="line">            user.save()</span><br><span class="line"></span><br><span class="line">            return redirect(&quot;show&quot;, id=id)</span><br><span class="line">    else:</span><br><span class="line">        form = UserForm(user.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return render(request, &quot;edit.html&quot;, &#123;&quot;form&quot;: form, &quot;user&quot;: user&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>CBV</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class UserUpdateView(UpdateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;edit.html&#x27;</span><br><span class="line">    success_url = reverse_lazy(&#x27;index&#x27;)</span><br><span class="line"></span><br><span class="line">    def get_object(self):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>使用 UpdateView 是需要傳遞 <code>pk</code> &#x2F; <code>slug</code> 去讓他找出資料</p><p>不過 User 剛好沒有這兩個欄位，所以就用了 <code>get_object</code> 來找資料</p><h4 id="DeleteView"><a href="#DeleteView" class="headerlink" title="DeleteView"></a>DeleteView</h4><p>只要 request 是 POST ，且資料存在的話，就會刪除</p><p>用 <code>Function-based views</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def delete(request, id=None):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">        user.delete()</span><br><span class="line">        return redirect(&quot;index&quot;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponseNotAllowed([&quot;POST&quot;])</span><br></pre></td></tr></table></figure><p>使用 <code>CBV</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class UserDeleteView(DeleteView):</span><br><span class="line">    model = User</span><br><span class="line">    success_url = reverse_lazy(&quot;index&quot;)</span><br><span class="line"></span><br><span class="line">    def get_object(self):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>Django 的 <code>Function-based views</code> 以及 <code>Class-based views</code> 各有擁護者，</p><p>且 <code>Class-based views</code> 並不是用來取代 <code>Function-based views</code> 的，他們各有所長</p><p>至於要使用哪個方式，我個人認為還是要照需求以及團隊的 coding style 來決定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提到 Views 之前，我們先來認識 MTV 架構&lt;/p&gt;
&lt;p&gt;Django 所採用的模式是 MTV 模式&lt;/p&gt;
&lt;p&gt;使用者瀏覽網頁時，伺服器的運作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;urls.py 會將 request 傳送至 View&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - urls 的那些基礎用法</title>
    <link href="http://ninglab.com/Django-urls-1/"/>
    <id>http://ninglab.com/Django-urls-1/</id>
    <published>2024-04-28T13:24:45.000Z</published>
    <updated>2024-05-12T11:19:02.141Z</updated>
    
    <content type="html"><![CDATA[<p>當使用者點選網址進入網站時，會發送 <code>request</code> 給伺服器，<br>不過伺服器怎麼知道他要做什麼，並且需要什麼資料呢？</p><p>今天要來介紹 Django 中的 urls </p><p><img src="https://imgur.com/L01upJS.jpg" alt="Ning-draw (30)"></p><h2 id="ROOT-URLCONF"><a href="#ROOT-URLCONF" class="headerlink" title="ROOT_URLCONF"></a>ROOT_URLCONF</h2><p>當使用者進入到網域中的其中一個頁面時，會發送 request 給 server</p><p>Django 收到時，會先去 <code>settings.py</code> 找 <code>ROOT_URLCONF</code></p><p>看看 URL 的設定放在哪個檔案中</p><p>可以將 <code>ROOT_URLCONF</code> 想像成百貨公司的樓層介紹，</p><p>當我們想要吃麥當勞的時候，該去哪層樓的哪個櫃位</p><p>假設今天要做一個電商網站，那麼就可以將 <code>urls.py</code> 在最上層的 module 中整合</p><p>以下方例子來說，我就會將 <code>ROOT_URLCONF</code> 設定為 <code>cake_shop.urls</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/settings.py</span><br><span class="line"></span><br><span class="line">ROOT_URLCONF = &#x27;cake_shop.urls&#x27;</span><br></pre></td></tr></table></figure><p>每個模組會有自己的 <code>urls</code> ，但個別模組的 urls.py 最後都會 include 到 <code>cake_shop.urls</code> 來彙整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── cake_shop</span><br><span class="line">│  ├── __init__.py</span><br><span class="line">│  ├── asgi.py</span><br><span class="line">│  ├── settings.py</span><br><span class="line">│  ├── urls.py</span><br><span class="line">│  └── wsgi.py</span><br><span class="line">├── member</span><br><span class="line">│  └── migration</span><br><span class="line">│  ├── __init__.py</span><br><span class="line">│  ├── app.py</span><br><span class="line">│  ├── admin.py</span><br><span class="line">│  ├── models.py</span><br><span class="line">│  ├── tests.py</span><br><span class="line">│  ├── urls.py</span><br><span class="line">│  └── views.py</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure><p>Django 知道該去哪裡找 <code>urls</code> 後，就會進到該 <code>urls.py</code> 中</p><h2 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h2><p><code>urls.py</code> 中會有個變數叫做 <code>urlpatterns</code> ，</p><p>在這個變數中，會指定一系列的 <code>path</code> 給他，</p><p>而這一系列的 <code>path</code> 會是 urls 模組底下的 <code>path 方法</code> 或者 <code>re_path 方法</code> 的實體</p><blockquote><p>This should be a sequence of django.urls.path() and&#x2F;or django.urls.re_path() instances</p></blockquote><p>Django 已經先幫我們做出一個管理員的路徑了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>讓我們來看一下 <code>path</code> 該怎麼寫吧</p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>Django 官方文件對於 path 方法規範如下：</p><blockquote><p>path(route, view, kwargs&#x3D;None, name&#x3D;None)</p></blockquote><p>讓我們來看一下參數：</p><p><code>route</code> 表示要顯示在網址上的路徑，前面不需要加上 <code>/</code> 因為原本的 URL 就會有了<br><code>view</code> 表示這個路徑要去找 <code>views.py</code> 中的哪個方法<br><code>kwargs</code> 指的是 <code>keyword argument</code> 也就是需要給他明確的 <code>keyword</code> 跟 <code>value</code><br><code>name</code> 方便我們用更簡潔且易讀的方式代表 URL</p><p>假設我們今天有個頁面需要顯示所有使用者的，這時候我就先會設定他的路徑</p><p>希望該頁面顯示的網址是 <code>https://網域/users</code><br>並且會去找 views 中的 index 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Path-Converter"><a href="#Path-Converter" class="headerlink" title="Path Converter"></a>Path Converter</h3><p>如果今天是要顯示該使用者的基本資料畫面呢？也就是俗稱的 <code>show</code> 頁面</p><p><code>path</code> 使用 <code>&lt;&gt;</code> 來捕捉裡面的參數，並會當作 <code>keyword argument</code> 傳入 views 中，所以我們就可以這樣寫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index),</span><br><span class="line">    path(&#x27;users/&lt;id&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Path Converter 預設的型態是字串，不過還有支援 <code>integer</code> &#x2F; <code>slug</code> &#x2F; <code>uuid</code> 甚至是完整的路徑也可以</p><p>當我們要讓參數傳進 views 中的方法，方法必需要加上 <code>positional argument</code> (<code>id</code>)，也名字必須要一樣，否則就會跑出錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/memeber/views.py</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id):</span><br><span class="line">    ...</span><br><span class="line">    return render(request, &quot;show.html&quot;)</span><br></pre></td></tr></table></figure><h4 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h4><p>如果型態不是字串必須要在前面加上 <code>int</code> 作為 <code>parameter</code></p><p>而傳進去的都需要叫這個名稱，以下方例子來說，參數都必須要叫 <code>height</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;int:height&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候的網址就會是 <code>https://網域/users/190/</code> </p><h4 id="slug"><a href="#slug" class="headerlink" title="slug"></a>slug</h4><p>同上，只要在前面加上 <code>slug</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;slug:slug&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h4><p>同上，只要在前面加上 <code>uuid</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;uuid:uuid&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="選填參數"><a href="#選填參數" class="headerlink" title="選填參數"></a>選填參數</h3><p>剛剛有提到，如果要傳參數進去，必須要在方法中也給他一個 <code>positional argument</code> </p><p>但如果有兩個路徑要同時去找同一個方法，一個路徑有傳遞參數，一個沒有傳遞參數呢？</p><p>我們可以在方法中 <code>parameter</code> 給他預設值，就算路徑沒有傳參數進來，也不會壞掉了</p><p>不過應該只會在 <code>有分頁的時候</code> <code>有搜尋的時候</code> 用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id = None):</span><br><span class="line">    ...</span><br><span class="line">    return render(request, &quot;show.html&quot;)</span><br></pre></td></tr></table></figure><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>當我們要在最上層的 <code>cake_shop</code> urls 中引入 <code>member</code> 的路徑時，</p><p>可以直接將 <code>member.urls</code> include 進來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, include(&quot;member.urls&quot;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>如果未來想要使用 url 這種方法，為了簡化路徑，我可以加上 <code>name</code> 關鍵字參數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>還可以搭配 <code>reverse</code> 讓程式碼更簡潔且易讀！</p><h4 id="path-reverse"><a href="#path-reverse" class="headerlink" title="path reverse"></a>path reverse</h4><p>當加入了 <code>name</code> 這個 <code>keyword argument</code> 之後，就可以在方法中用 <code>reverse</code> 簡化路徑的寫法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line">from django.urls import reverse</span><br><span class="line">from django.http import HttpResponseRedirect</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id = None):</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;index&quot;))</span><br></pre></td></tr></table></figure><ul><li>如果搭配 <code>HttpResponseRedirect</code> 的話不要重新導向到自己本身的方法，不然就會造成無窮迴圈，以上述的例子來說，如果我在 index 方法導向到 index，就會無窮迴圈</li></ul><p>在 form 的話我們就可以在 url 的方法，用易讀又簡短的方式寫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&#123;% url &#x27;index&#x27; %&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="namespaces"><a href="#namespaces" class="headerlink" title="namespaces"></a>namespaces</h4><p>當專案複雜度增加，模組也可能會跟著增加，這時候可能會遇到相同路徑名稱的問題，</p><p>name 命名可能因此越來越長，這時候我們可以使用 <code>namespace</code> 來做區隔 (前提是要給 name 參數唷！)</p><p>namespace 有分成兩種</p><ol><li>application namespace</li></ol><p>每個 application 都可以有自己的 namespace ，且他們的實體前綴也會有 namespace 名稱</p><p>我們可以用 <code>app_name</code> 來設定 application namespace</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">app_name = &quot;users&quot;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候 views 的 reverse 路徑就可以設定成 <code>users:index</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">def show(request, id=None):</span><br><span class="line">    print(id)</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;users:index&quot;))</span><br></pre></td></tr></table></figure><ol start="2"><li>instance namespace</li></ol><p>實體的 namespace 在這專案中必須是要獨一無二的，如果沒有特別設定，預設就會是 application 的 namespace</p><p>namespace 會用 <code>:</code> 來區隔</p><p>如果我們在 include 的時候有指定 namespace ，這時候該路徑就會被套上 instance namespace</p><p>我們可以在 cake_shop 底下的 urls.py 設定 <code>instance namespace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/urls.py</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, include(&quot;member.urls&quot;, namespace=&quot;admin&quot;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候 views 的 reverse 路徑就可以設定成 <code>admin:index</code> ，我們可以指定 current_app 告訴他要去找哪個 <code>application namespace</code> 底下的 <code>instance namespace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">def show(request, id=None):</span><br><span class="line">    print(id)</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;admin:index&quot;, current_app=&quot;users&quot;))</span><br></pre></td></tr></table></figure><p><code>reverse</code> 若有指定 current_app 這個參數時，就會去找這個值的 namespace</p><p>沒有的話，就會去找 application namespace </p><p>再沒有的話，就會去找 instance namespace</p><p><img src="https://imgur.com/PUBtSuT.jpg" alt="Ning-draw (30)"></p><p>今天先介紹比較基礎的 URL 用法，下一篇我們會再介紹更深入的 URL 用法</p><p>如果喜歡這篇文章歡迎幫我點選下方的 Like</p><p>如果上述文章有任何疑慮或者指教，也歡迎留言</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;當使用者點選網址進入網站時，會發送 &lt;code&gt;request&lt;/code&gt; 給伺服器，&lt;br&gt;不過伺服器怎麼知道他要做什麼，並且需要什麼資料呢？&lt;/p&gt;
&lt;p&gt;今天要來介紹 Django 中的 urls &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgur.co</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Python - 函式裝飾器 function decorator</title>
    <link href="http://ninglab.com/Python-function-decorator/"/>
    <id>http://ninglab.com/Python-function-decorator/</id>
    <published>2024-04-21T15:29:34.000Z</published>
    <updated>2024-04-26T13:57:33.579Z</updated>
    
    <content type="html"><![CDATA[<p>今天想來跟大家介紹 function decorator</p><h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>在這之前，先介紹一下什麼叫做 <code>Higher-order function</code>，就會比較好理解 function decortor</p><p>根據維基百科的介紹，<code>Higher-order function</code> 必須至少滿足以下其中一個條件</p><ol><li>至少有一個或多個 functions 作為引數</li><li>結果要返回一個 function</li></ol><blockquote><p>In mathematics and computer science, a higher-order function (HOF) is a function that does at least one of the following:</p><ol><li>takes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a procedure that is itself a procedure),</li><li>returns a function as its result.</li></ol></blockquote><p>讓我們來看看例子吧</p><p>當我們呼叫 <code>outer_fun</code> 時，傳了一個 function 做為引數，符合了 <code>Higher-order function</code> 的第一條規範，這時我們可以說 <code>outer_fun</code> 是個 <code>Higher-order function</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  print(inner_fun)</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // &lt;function inner_fun at 0x1029eccc0&gt;</span><br></pre></td></tr></table></figure><ul><li>不過如果我們在呼叫的時候，傳進去的引數不是 <code>function</code> ，然後也沒有 <code>return function</code> (第二個定義)，<br><code>outer_fun</code> 就不能被稱作是個 <code>Higher-order function</code></li></ul><p>接著我們再稍微加工一下，在 <code>outer_fun</code> 中定義一個 function 並且 return 此 function，也就是 <code>inner_fun</code> ，這時候符合了第二點的規範，<code>outer_fun</code> 就是個 <code>Higher-order function</code> 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun():</span><br><span class="line">  def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line">  </span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">outer_fun() // inner_fun 沒有執行，所以是空的</span><br></pre></td></tr></table></figure><p>我們再來點進階的範例，我們來一步步看</p><ol><li>定義了一個 function <code>outer_fun</code></li><li>foo 被指向 <code>outer_fun</code> ，帶入 3 為引數並且執行</li><li>定義了一個 function <code>inner_fun</code></li><li>回傳 <code>inner_fun</code> 這個物件，此時 foo 是指向 <code>inner_fun</code> 這個物件</li></ol><p>這時候的 <code>outer_fun</code> 也是回傳一個 function ，符合 <code>Higher-Order function</code> 第二個定義，因此可稱為 <code>Higher-Order function</code></p><p><code>outer_fun</code> 回傳的是 <code>inner_fun</code> 這個 function 物件，</p><p>並非 <code>inner_fun</code> 的執行結果，因此在執行程式碼並不會印出任何東西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(x):</span><br><span class="line">  def inner_fun(x):</span><br><span class="line">    calculator = x + x</span><br><span class="line">    print(calculator)</span><br><span class="line"></span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">foo = outer_fun(3)</span><br></pre></td></tr></table></figure><p>現在的 foo 指向了 <code>inner_fun</code> 這個 function 物件，</p><p>如果我們想要 <code>inner_fun</code> 執行結果的話，只要執行 foo 並且帶入參數即可</p><p>這時候的 <code>outer_fun</code> 回傳的仍然是 <code>inner_fun</code> 這個 function 物件，因此仍為 <code>Higher-Order function</code></p><ol><li>定義了一個 function <code>outer_fun</code></li><li>foo 被指向 <code>outer_fun</code> ，帶入 3 為引數並且執行</li><li>定義了一個 function <code>inner_fun</code></li><li>回傳 <code>inner_fun</code> 這個物件，此時 foo 是指向 <code>inner_fun</code> 這個物件</li><li>foo 執行，也就是 <code>inner_fun</code> 執行，帶入 3 作為引數並執行</li><li>進入 <code>inner_fun</code></li><li>計算 引數相加 <code>x + x</code> ，算出結果為 3 ，並將 calculator 指向該結果</li><li>印出 calculator</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(x):</span><br><span class="line">  def inner_fun(x):</span><br><span class="line">    calculator = x + x</span><br><span class="line">    print(calculator)</span><br><span class="line"></span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">foo = outer_fun(3)</span><br><span class="line"></span><br><span class="line">foo(3) // 6</span><br></pre></td></tr></table></figure><p>到這邊大家應該對於 <code>Higher-Order function</code> 多少有個概念了</p><p>再複習一下，<code>Higher-Order function</code> 需要符合以下其中一個定義</p><ol><li>至少有一個或多個 functions 作為引數</li><li>結果要返回一個 function</li></ol><p>那我們就帶著這兩個觀念，來看 <code>function decorator</code></p><h3 id="Decorator-pattern"><a href="#Decorator-pattern" class="headerlink" title="Decorator pattern"></a>Decorator pattern</h3><p><code>function decorator</code> 是一種設計模式，並不是只有存在於 Python ，其他程式語言，像是 JavaScript 或 Ruby 也會有，概念都是差不多的，只是差在於使用的頻率高不高</p><p>這個設計模式被稱作為 <code>Decorator pattern</code> </p><p>我們來看看維基百科的介紹</p><p>在物件導向程式中， <code>Decorator pattern</code> 在不影響同個類別下的其他實體，可以讓獨立的物件添加其他行為</p><blockquote><p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other instances of the same class.</p></blockquote><p>我們來就拿第一個範例來看，為了方便了解，我會將 <code>outer_fun</code> 的程式碼改為 return inner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // return inner_fun 該物件</span><br></pre></td></tr></table></figure><p>為了要拿到傳進去 outer_fun 的 function 引數的執行結果，我們將程式碼這樣改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner()</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // I&#x27;m inner function</span><br></pre></td></tr></table></figure><p>這樣看起來還算蠻單純的，不過這不算是 <code>Decorator pattern</code>，這只是一般的 <code>Higher-Order function</code></p><p>來看看 GeeksforGeeks 的解釋：<br><code>Decorator</code> 可以讓你動態的在物件上增加行為，並且當被包裝起來的那個 function (這邊稱 wrapper) 在調用的時候不會改變原本的行為</p><blockquote><p>Decorator Method is a Structural Design Pattern which allows you to dynamically attach new behaviors to objects without changing their implementation by placing these objects inside the wrapper objects that contains the behaviors.</p></blockquote><p>如果今天專案中的許多地方都有用到 outer_fun ，改了 <code>outer_fun</code> 就可能會出錯，假設有個地方傳進去的是字串，他應該就會引發字串無法呼叫這個訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner()</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(&quot;aa&quot;) // TypeError: &#x27;str&#x27; object is not callable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這時候我們使用 function decorator 來改剛剛的例子，只要掛上這層外衣，就可以執行</p><ul><li>Python 提供了我們 <code>@</code> 的語法糖衣，讓 Decorator pattern 寫起來更易讀</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer_fun</span><br><span class="line">def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">inner_fun() // I&#x27;m inner function</span><br></pre></td></tr></table></figure><p>即便今天有其他地方不是傳 function 進去，也不會噴錯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer_fun</span><br><span class="line">def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">inner_fun() // I&#x27;m inner function</span><br><span class="line">outer_fun(3) // 不會印出任何東西，會 return inner function</span><br></pre></td></tr></table></figure><p>如果是比較複雜的狀況呢，讓我們來看看 BMI 計算機</p><p>以我自己的做法，會先處理身高，處理完再將它丟到 BMI 計算的 function 中去做計算</p><p>不過這樣在使用的時候就會傳一大堆參數，而且 <code>calculator(bmi_calculator, 50, 160) </code> 這樣寫起來並不直觀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func, weight, height):</span><br><span class="line">    height_in_meters = height / 100</span><br><span class="line">    return func(weight, height_in_meters)</span><br><span class="line"></span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    bmi = weight / (height ** 2)</span><br><span class="line">    return bmi</span><br><span class="line"></span><br><span class="line">result = calculator(bmi_calculator, 50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>如果是使用 Decorator Pattern 的方式</p><p>一開始我會將身高丟到 calculator 中，<br>並且在 calculate_height 中處理身高，<br>最後呼叫 bmi_calculator 來得到結果 </p><p>我們可以把 calculator 想像成一間代工廠，將所有的生產線用一個工廠包裝起來</p><p>而在這個工廠中，我會各別處理元件，處理完的元件會個別組裝起來，最後送出成品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func):</span><br><span class="line">  def calculate_height(weight, height):</span><br><span class="line">    height_in_meters = height / 100</span><br><span class="line">    </span><br><span class="line">    return func(weight, height_in_meters)</span><br><span class="line">  return calculate_height</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    return weight / (height * height)</span><br><span class="line"></span><br><span class="line">decorated_bmi_calculator = calculator(bmi_calculator)</span><br><span class="line">result = decorated_bmi_calculator(50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>上述的方式，我個人認為已經簡潔許多，不過在呼叫的時候還是很麻煩，而且易讀性不高</p><p>我們來 <code>@</code> 這個語法糖衣來簡化一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func):</span><br><span class="line">    def calculate_height(weight, height):</span><br><span class="line">        def square_height(height):</span><br><span class="line">            height_in_meters = height / 100</span><br><span class="line"></span><br><span class="line">            return height_in_meters</span><br><span class="line">        return func(weight, square_height(height))</span><br><span class="line"></span><br><span class="line">    return calculate_height</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@calculator</span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    return weight / (height * height)</span><br><span class="line"></span><br><span class="line">result = bmi_calculator(50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>這樣就看起來簡潔又易讀囉！</p><h3 id="總結-何時會需要用到-function-decorator"><a href="#總結-何時會需要用到-function-decorator" class="headerlink" title="總結 - 何時會需要用到 function decorator ?"></a>總結 - 何時會需要用到 function decorator ?</h3><p>再來回顧一下 Decorator pattern 的概念</p><p><code>Decorator</code> 可以讓你動態的在物件上增加行為，並且當被包裝起來的那個 function (這邊稱 wrapper) 在調用的時候不會改變原本的行為</p><blockquote><p>Decorator Method is a Structural Design Pattern which allows you to dynamically attach new behaviors to objects without changing their implementation by placing these objects inside the wrapper objects that contains the behaviors.</p></blockquote><p>我自己會歸類成幾個時候需要使用：</p><ol><li>不想改變原本的程式碼</li></ol><p>就像剛剛的 <code>outer_fun</code> 跟 <code>inner_fun</code> 的範例</p><ol start="2"><li>有多種額外的行為需要做時</li></ol><p>以剛剛的 BMI 計算機來看，我們需要先處理身高，再進行計算，這時候就很適合用 <code>function decorator</code></p><p>不然用一般的方式需要傳入很多參數，且也不好閱讀，我們就可以用 <code>function decorator</code> 來優化</p><ol start="3"><li>使用套件的方法時</li></ol><p>也許我們在做專案的時候用不太到 <code>function decorator</code> ，不過多少應該都會用到套件，</p><p>像是在 Flask 的路徑會使用到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return &#x27;Hello, World!&#x27;</span><br></pre></td></tr></table></figure><p>Django 的方法多少也會用到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_required</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>參考資料：<br><a href="https://www.geeksforgeeks.org/decorator-method-python-design-patterns/">https://www.geeksforgeeks.org/decorator-method-python-design-patterns/</a></p><p><a href="https://en.wikipedia.org/wiki/Decorator_pattern">https://en.wikipedia.org/wiki/Decorator_pattern</a></p><p><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></p>]]></content>
    
    
    <summary type="html">Python 中的 @ 是什麼？原來 function 也需要大衣來包裝自己！</summary>
    
    
    
    <category term="Python" scheme="http://ninglab.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Ruby-用 Rack 做出自己的 Router</title>
    <link href="http://ninglab.com/Ruby-build-your-own-router-by-rack/"/>
    <id>http://ninglab.com/Ruby-build-your-own-router-by-rack/</id>
    <published>2024-04-14T08:39:15.000Z</published>
    <updated>2024-04-14T09:30:48.240Z</updated>
    
    <content type="html"><![CDATA[<p>在之前 Rebuild Rails 時有介紹到 <a href="https://ninglab.com/%E5%BE%9E0%E9%96%8B%E5%A7%8B%E5%88%BB-%E6%B7%BA%E8%AB%87-Rails-%E7%9A%84%E9%81%8B%E4%BD%9C%E9%AD%94%E6%B3%95-Day02-Rack/">Rack</a> </p><p>對於 Rack 更精準的解釋是，<br>Rack 本身是個 Ruby 與 framework 的規範，<br>符合規範的 framework 稱作是 <code>Rack application</code> ，會將程式碼處理成 Rack 規範認可的格式(也就是 object ，且可以 call) 給 WebServer</p><p>而 <code>Rack</code> 這個套件，可以透過 <code>rackup</code> 指令產生介面，讓 Rack application 運行在支援的 Server 上</p><p>當我們用純 Ruby 來寫程式，要讓用戶連上我們的服務時，要怎麼樣才可以讓程式連上 Server ？</p><p>以下來示範一段程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;webrick&#x27;</span><br><span class="line"></span><br><span class="line"># 建立 WEBrick HTTP 伺服器</span><br><span class="line">server = WEBrick::HTTPServer.new(Port: 3000)</span><br><span class="line"></span><br><span class="line"># 設定 Route 和處理請求</span><br><span class="line">server.mount_proc &#x27;/&#x27; do |req, res|</span><br><span class="line">  res.body = &#x27;Hello! Rack Practice&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 設定伺服器需要停止的狀況</span><br><span class="line">trap &#x27;INT&#x27; do server.shutdown end</span><br><span class="line"></span><br><span class="line"># 啟動伺服器</span><br><span class="line">server.start</span><br></pre></td></tr></table></figure><p>這樣可以讓程式碼連上 Server ，不過除了要手動一個一個寫 Route 以外，還要額外設定回應的 Body</p><p>而且，如果今天要回應的是一個 <code>html.erb</code> 檔案或者需要執行到 <code>rb</code> 檔呢？</p><p>需要寫一段程式碼去讀取檔案，或者 <code>require</code> 檔案並且渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;webrick&#x27;</span><br><span class="line"></span><br><span class="line">server = WEBrick::HTTPServer.new(Port: 3000)</span><br><span class="line"></span><br><span class="line">server.mount_proc &#x27;/&#x27; do |req, res|</span><br><span class="line">  res.body = File.open(&#x27;public/index.html.erb&#x27;, File::RDONLY)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">trap &#x27;INT&#x27; do server.shutdown end</span><br><span class="line">server.start</span><br></pre></td></tr></table></figure><p>其實這樣是蠻麻煩的</p><p>Ruby 的框架大多遵守 Rack 的規範，讓開發者可以輕鬆處理 Route 以及 Response</p><p>為了以防大家混淆，如果講到 <code>Rack 規範</code> 我會直接使用 <code>Rack 規範</code> 來稱呼</p><p>Rack 本身支援多種 Server，舉凡開發階段使用的 <code>Puma</code> &#x2F; <code>Thin</code> ，或者是正式階段使用的 <code>NGINX</code> 都有</p><blockquote><p>This specification aims to formalize the Rack protocol.</p></blockquote><p>Rack 的官方文件提到，這些規範是為了要正式化 Rack 的 protocol</p><h3 id="用-Rack-來刻一個-Router"><a href="#用-Rack-來刻一個-Router" class="headerlink" title="用 Rack 來刻一個 Router"></a>用 Rack 來刻一個 Router</h3><p><a href="https://github.com/cacachang/rack_practice">Source Code</a></p><p>檔案的架構長這樣</p><p><code>public</code> 會放置靜態檔案<br><code>Gemfile</code> <code>Gemfile.lock</code> 會放我們該專案所需要的套件<br><code>config.ru</code> Rack 會需要解析這個檔案，去決定他該做什麼事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rack_practice</span><br><span class="line">├── public</span><br><span class="line">│  └──index.html.erb</span><br><span class="line">├── Gemfile</span><br><span class="line">├── Gemfile.lock</span><br><span class="line">└── config.ru</span><br></pre></td></tr></table></figure><h4 id="step-1-建立一個-Rack-base-的-Application"><a href="#step-1-建立一個-Rack-base-的-Application" class="headerlink" title="step 1. 建立一個 Rack base 的 Application"></a>step 1. 建立一個 Rack base 的 Application</h4><p>剛有提到 Rack 會去解析 <code>config.ru</code> ，而我們會將設定寫在 <code>Rack::Builder.new</code> 的 block 之中，讓 Rack 知道，我們需要藉由這些設定來連接 Server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><code>Rack::Builder</code> - 用來架構一個 Rack application</li></ul><blockquote><p>Rack::Builder provides a domain-specific language (DSL) to construct Rack applications.</p></blockquote><h4 id="step-2-定義該路徑要渲染哪個檔案"><a href="#step-2-定義該路徑要渲染哪個檔案" class="headerlink" title="step 2. 定義該路徑要渲染哪個檔案"></a>step 2. 定義該路徑要渲染哪個檔案</h4><p>接著會需要設定 Route ，我們先從最簡單的 <code>/</code> 開始<br>我希望 root_path 要渲染 <code>public/index.html.erb</code> 這個靜態檔案</p><p>這時候我們可以使用 <code>Rack::Static</code> 這個方法</p><ul><li><code>Rack::Static</code> - 去攔截靜態檔案的 url 的 prefix 或者是 option 裡面的路徑參數，並且用 <code>Rack::Files</code> 來渲染畫面(root 參數指的是要在哪個資料夾找檔案)</li></ul><blockquote><p>The Rack::Static middleware intercepts requests for static files (javascript files, images, stylesheets, etc) based on the url prefixes or route mappings passed in the options, and serves them using a Rack::Files object.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  map &#x27;/&#x27; do</span><br><span class="line">    use Rack::Static, urls: [&#x27;/&#x27;], root: &#x27;public&#x27;, index: &#x27;index.html.erb&#x27;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-3-設定頁面的-Response"><a href="#step-3-設定頁面的-Response" class="headerlink" title="step 3. 設定頁面的 Response"></a>step 3. 設定頁面的 Response</h4><p>在 run 這個 lambda 中，我們要回應 <code>status</code> &#x2F; <code>headers</code> &#x2F; <code>body</code></p><ul><li><code>Rack 規範</code>中有規定 Rack application 是個 Ruby 物件，並且要透過 call 來回應，需要以 env 為參數，並且回傳一個陣列，要包含著 <code>status</code> &#x2F; <code>headers</code> &#x2F; <code>body</code></li></ul><blockquote><p>A Rack application is a Ruby object (not a class) that responds to call. It takes exactly one argument, the environment and returns a non-frozen Array of exactly three values: The status, the headers, and the body.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  map &#x27;/&#x27; do</span><br><span class="line">    use Rack::Static, urls: [&#x27;/&#x27;], root: &#x27;public&#x27;, index: &#x27;index.html.erb&#x27;</span><br><span class="line">    run lambda &#123; |_env|</span><br><span class="line">      [</span><br><span class="line">        200,</span><br><span class="line">        &#123;</span><br><span class="line">          &#x27;Content-Type&#x27;: &#x27;text/html&#x27;,</span><br><span class="line">          &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        File.open(&#x27;public/index.html.erb&#x27;, File::RDONLY)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-4-設定-Server-停止的條件"><a href="#step-4-設定-Server-停止的條件" class="headerlink" title="step 4. 設定 Server 停止的條件"></a>step 4. 設定 Server 停止的條件</h4><p>Signal 指的是信號，簡單來說，就是收到中斷訊號時( <code>Ctrl+C</code> ) 的時候中斷 Server </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">Signal.trap &#x27;INT&#x27; do</span><br><span class="line">  Rack::Handler::WEBrick.shutdown</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-5-啟動-Server"><a href="#step-5-啟動-Server" class="headerlink" title="step 5. 啟動 Server"></a>step 5. 啟動 Server</h4><p>這邊我使用 <code>WEBrick</code> 作為 Server，指定 Port 3000 給他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">Rack::Handler::WEBrick.run app, Port: 3000</span><br></pre></td></tr></table></figure><p>不過這樣我們只能瀏覽 <code>/</code>，接著我們來做點進階的吧！</p><h4 id="step-1-設定-Router"><a href="#step-1-設定-Router" class="headerlink" title="step 1. 設定 Router"></a>step 1. 設定 Router</h4><p>檔案架構長這樣</p><p>會多兩個檔案，</p><p><code>router.rb</code> 設定哪個 route 會回傳什麼訊息<br><code>application.rb</code> 依照路徑來做出 Response (呼叫 Rack 規定的 object)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rack_practice</span><br><span class="line">├── public</span><br><span class="line">│  └──index.html.erb</span><br><span class="line">├── router.rb</span><br><span class="line">├── application.rb</span><br><span class="line">├── Gemfile</span><br><span class="line">├── Gemfile.lock</span><br><span class="line">└── config.ru</span><br></pre></td></tr></table></figure><p>Router 初始化的時候是個空的 {} ，這邊裝的資料會是 Response 的 body</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>接著要要設定一個方法，放置渲染的訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def get(path, &amp;block)</span><br><span class="line">    @routes[path] = block</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>最後建立一個 Response ，將對應的訊息回傳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def get(path, &amp;block)</span><br><span class="line">    @routes[path] = block</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def build_response(path)</span><br><span class="line">    handler = @routes[path] || -&gt; &#123; &quot;no route found for #&#123;path&#125;&quot; &#125; </span><br><span class="line">    handler.call</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以上我們就做好 Router 了，接著要來路徑所對應的訊息內容</p><h4 id="step-2-設定-Application"><a href="#step-2-設定-Application" class="headerlink" title="step 2. 設定 Application"></a>step 2. 設定 Application</h4><p>一開始 Application 被 new 出來的時候，要做一個 Router ，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>接著會使用到 <code>Router.rb</code> 裡面的 <code>get</code> 方法來設定對應的渲染訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line"></span><br><span class="line">    @router.get(&#x27;/&#x27;) &#123; &#x27;Welcome to Rack Practice&#x27;&#125;</span><br><span class="line">    @router.get(&#x27;/article&#x27;) &#123; &#x27;All Articles&#x27; &#125; </span><br><span class="line">    @router.get(&#x27;/article/1&#x27;) &#123; &#x27;First Articles&#x27; &#125; </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>這時候 @router 會長這樣</p><p>每個路徑會指向一個 <code>Proc</code>，而這個 <code>Proc</code> 就會放置我們給他的訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;/&quot;=&gt;#&lt;Proc:0x000000010aed8ce8   </span><br><span class="line">  /Users/.../rack_practice/application.rb:9&gt;, </span><br><span class="line">  &quot;/article&quot;=&gt;#&lt;Proc:0x000000010aed8c98 </span><br><span class="line">  /Users/.../rack_practice/application.rb:10&gt;, </span><br><span class="line">  &quot;/article/1&quot;=&gt;#&lt;Proc:0x000000010aed8c48 </span><br><span class="line">  /Users/.../rack_practice/application.rb:11&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定完成後，我們就可以來做 Response 了</p><p>進入到這些畫面的時候</p><p>status 會是 200<br>headers 都是 “text&#x2F;html”<br>只有 body 會不一樣，會像上一步做的，依照進入的頁面不同，渲染不同的訊息</p><p>這時候我們會需要用到 <code>Router.rb</code> 中的  <code>build_response</code><br>將 <code>env[&#39;PATH_INFO&#39;]</code> 當參數傳進去，<br><code>build_response</code> 就會去判斷他是 @router 中的哪個路徑，<br>並依照路徑渲染訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line"></span><br><span class="line">    @router.get(&#x27;/&#x27;) &#123; &#x27;Welcome to Rack Practice&#x27;&#125;</span><br><span class="line">    @router.get(&#x27;/article&#x27;) &#123; &#x27;All Articles&#x27; &#125; </span><br><span class="line">    @router.get(&#x27;/article/1&#x27;) &#123; &#x27;First Articles&#x27; &#125; </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def call(env)</span><br><span class="line">    headers = &#123;</span><br><span class="line">      &quot;Content-Type&quot; =&gt; &quot;text/html&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = @router.build_response(env[&#x27;PATH_INFO&#x27;])</span><br><span class="line"></span><br><span class="line">    [200, headers, [response]]</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-3-設定進入點"><a href="#step-3-設定進入點" class="headerlink" title="step 3. 設定進入點"></a>step 3. 設定進入點</h4><p>我們只要將 <code>Rack::Builder</code> 中改成 <code>run Application.new</code><br>在跑 <code>rackup</code> 指令的時候，就會去 new 一個 Application ，並且 run 起來囉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">require &#x27;webrick&#x27;</span><br><span class="line">require &#x27;./application&#x27;</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  run Application.new</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Signal.trap &#x27;INT&#x27; do</span><br><span class="line">  Rack::Handler::WEBrick.shutdown</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Rack::Handler::WEBrick.run app, Port: 3000</span><br></pre></td></tr></table></figure><p>以上是比較陽春的 Router ，要達到 Rails 的版本還有很多東西要處理，這部分我們之後會再介紹</p><p>參考</p><p><a href="https://github.com/rack/rack">https://github.com/rack/rack</a></p><p><a href="https://tommaso.pavese.me/2016/07/26/a-rack-application-from-scratch-part-2-routes-and-controllers/">https://tommaso.pavese.me/2016/07/26/a-rack-application-from-scratch-part-2-routes-and-controllers/</a></p><p><a href="https://www.writesoftwarewell.com/build-your-own-router-in-ruby/">https://www.writesoftwarewell.com/build-your-own-router-in-ruby/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前 Rebuild Rails 時有介紹到 &lt;a href=&quot;https://ninglab.com/%E5%BE%9E0%E9%96%8B%E5%A7%8B%E5%88%BB-%E6%B7%BA%E8%AB%87-Rails-%E7%9A%84%E9%81%8B%E4</summary>
      
    
    
    
    <category term="Ruby" scheme="http://ninglab.com/categories/Ruby/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 運行背後的世界(1)</title>
    <link href="http://ninglab.com/JavaScript-execution-context-1/"/>
    <id>http://ninglab.com/JavaScript-execution-context-1/</id>
    <published>2024-03-31T15:41:20.000Z</published>
    <updated>2024-04-10T17:56:29.248Z</updated>
    
    <content type="html"><![CDATA[<p>當 JavaScript 開始執行的時候，背後會做一連串複雜的事情，我們今天就來看看這背後複雜的流程吧</p><p><img src="https://imgur.com/nsX7yj6.jpg" alt="Ning-draw (4)"></p><p>JS 開始運行時，就會啟動<code>執行環境</code></p><h3 id="Execution-Context-執行環境"><a href="#Execution-Context-執行環境" class="headerlink" title="Execution Context 執行環境"></a>Execution Context 執行環境</h3><blockquote><p>An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation.</p></blockquote><p>依照 ECMA 官方的解釋，執行環境是在程式碼執行的時候發生，並且用來追蹤程式碼的執行狀況</p><p>而執行環境又分成兩種，分別是<br><code>Global Execution Context</code><br><code>Function Execution Context</code></p><p>當程式碼開始執行時，<code>Global Execution Context</code> 就會開始，他的作用域在程式碼開始到結束</p><h3 id="Global-Execution-Context-GEC"><a href="#Global-Execution-Context-GEC" class="headerlink" title="Global Execution Context (GEC)"></a>Global Execution Context (GEC)</h3><p>又稱作全域執行環境，這個時候，會將 window 做出來，並且將 this 綁定在 window 身上</p><p>我們可以在檢查中輸入 <code>window</code> <code>this</code>，並且看他們兩個是否是一一樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; window </span><br><span class="line">&gt; this</span><br><span class="line"></span><br><span class="line">&gt; window === this // true</span><br></pre></td></tr></table></figure><p>另外還會將變數存放到「倉庫」中，</p><p>倉庫又分成兩種，</p><ol><li>LexicalEnvironment 存放 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code></li><li>VariableEnvironment 存放 <code>var</code></li></ol><p>我們先知道有這兩個倉庫，待會再來仔細介紹這兩個倉庫</p><p>全域執行環境會一路到程式碼結束，那另一個執行環境呢？</p><h3 id="Function-Execution-Context-FEC"><a href="#Function-Execution-Context-FEC" class="headerlink" title="Function Execution Context (FEC)"></a>Function Execution Context (FEC)</h3><p>又稱為函式執行環境，當程式碼遇到 Function 或 block 時，就會產生 <code>Function Execution Context</code> ，</p><p>跟全域執行環境一樣，會將 function 中的變數及 function 存到倉庫中</p><p>到現在應該對於執行環境還有一點不了解，讓我們用 Stack 來看會更清楚</p><p>來看看下面的程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  console.log(&quot;Hi, my name is Ning&quot;);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(&quot;I&#x27;m 18 years old&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><p>當程式碼開始執行時，就像是大隊接力開始，執行到哪行程式碼，就是將控制所有權交給該 <code>Execution Context</code></p><ol><li><p>開始執行時，第一棒會是 <code>Global Execution Context</code>，</p></li><li><p>接著執行 <code>aboutMe()</code> ，產生一個 <code>Function Execution Context</code> ，並將所有權交給 <code>aboutMe()</code></p></li><li><p>接著在 <code>aboutMe()</code> 中執行了 <code>myAge()</code> ，因此產生一個新的 <code>Function Execution Context</code> ，並將所有權交給 <code>myAge()</code></p></li><li><p>當 <code>myAge()</code> 執行完後，<code>Function Execution Context</code> 就會消失，並且將控制權轉還交給 <code>aboutMe()</code> </p></li><li><p><code>aboutMe()</code> 執行後，<code>Function Execution Context</code> 就會消失，並將控制權轉交給 <code>Global Execution Context</code></p></li></ol><p><img src="https://imgur.com/uKucytz.jpg" alt="Ning-draw (10)"></p><p>接著我們要來看每個 <code>Execution Context</code> 中做了哪些事</p><p>剛剛有提到，不管是 <code>Global Execution Context</code> 還是 <code>Function Execution Context</code> 都會將他們的變數放到倉庫中</p><p>倉庫還會分成兩種倉庫</p><p>我們先來看第一種 <code>Lexical Environment</code></p><h3 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h3><p>Lexical Environment 又稱作詞彙環境，</p><p>會放置 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code> 不過還會有個地方放置父層的變數，</p><p>當執行的時候需要這個作用域沒有定義的變數，就可以往父層的變數小房間去找</p><p>因此 Lexical Environment 又分成兩個小盒子</p><p>第一個盒子是 <code>Environment Record</code>，放置 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code> 等變數</p><p>第二個盒子是 <code>reference to outer environment</code>，放置父層的變數</p><p>讓我們來看看幾個例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line">  console.log(`Hi, my name is $&#123;myName&#125;`);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    let age = 18;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>呼叫 <code>AboutMe()</code></li><li>進入到 <code>AboutMe</code> 的 <code>Function Execution Context</code></li><li>放置變數及 Function 到倉庫中， <code>myName</code> &#x2F; <code>myAge</code> <ul><li><code>myName</code> 是 var 變數，因此會放到 <code>Variable Environment</code> (待會會提到)</li><li><code>myAge</code> 是 Function ，會放到 <code>Environment Record</code></li></ul></li><li>印出 <code>Hi, my name is $&#123;myName&#125;</code>，由於 <code>Variable Environment</code> 有 <code>myName</code> 變數，因此印出 <code>Hi, my name is Ning</code></li><li>呼叫 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>放置變數<ul><li><code>age</code> 是 let 變數，因此放到 <code>Environment Record</code></li></ul></li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code> ，這時候 <code>myAge</code> 的 <code>Environment Record</code> 有 <code>age</code> 這個變數，因此印出  <code>I&#39;m 18 years old</code></li></ol><p><img src="https://imgur.com/k2mgVMy.jpg" alt="Ning-draw (6)"></p><p>接著我們來看有使用到父層變數的程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line">  let age = 18;</span><br><span class="line">  console.log(`Hi, my name is $&#123;myName&#125;`);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>呼叫 <code>AboutMe()</code></li><li>進入到 <code>AboutMe</code> 的 <code>Function Execution Context</code></li><li>放置變數及 Function 到倉庫中， <code>myName</code> &#x2F; <code>age</code> &#x2F; <code>myAge</code> <ul><li><code>myName</code> 是 var 變數，因此會放到 <code>Variable Environment</code></li><li><code>age</code> 是 let 變數，因此會放到 <code>Environment Record</code></li><li><code>myAge</code> 是 Function ，會放到 <code>Environment Record</code></li></ul></li><li>印出 <code>Hi, my name is $&#123;myName&#125;</code>，由於 <code>Variable Environment</code> 有 <code>myName</code> 變數，因此印出 <code>Hi, my name is Ning</code></li><li>呼叫 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>沒有變數</li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code> ，這時候 <code>myAge</code> 的 <code>Environment Record</code> 沒有 <code>age</code> 這個變數，因此往 <code>reference to outer environment</code> 找變數，在 <code>aboutMe</code> 找到了 age 是 18，因此印出 <code>I&#39;m 18 years old</code></li></ol><p>要注意的是， <code>reference to outer environment</code> 只會放上一層的，如果沒有的話，就會從上一層的 <code>reference to outer environment</code> 繼續往上找</p><p><img src="https://imgur.com/7qkuMF5.jpg" alt="Ning-draw (7)"></p><p>接著我們來看看 <code>Variable Environment</code></p><h3 id="Variable-Environment"><a href="#Variable-Environment" class="headerlink" title="Variable Environment"></a>Variable Environment</h3><p>又稱作變數環境，主要放置 <code>var</code> 變數，</p><p>接下來再看一個範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (myName == &quot;Ning&quot;) &#123;</span><br><span class="line">    let age = 19;</span><br><span class="line">    myAge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>執行 <code>aboutMe()</code></li><li>進入 <code>aboutMe</code> 的 <code>Function Execution Context</code> </li><li>放置變數 <ul><li>放置 var 變數 <code>myName</code> 到 <code>Variable Environment</code></li><li>放置 Function <code>myAge</code> 到 <code>Lexical Environment</code></li></ul></li><li>遇到 if 的 block ，進入該 block 的 <code>Function Execution Context</code></li><li>放置變數 <code>age</code> 到 <code>Lexical Environment</code></li><li>執行 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>沒有變數，不放置變數</li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code>，不過該 <code>Execution Context</code> 沒有任何變數，往 <code>reference to outer environment</code> 找</li><li>在 <code>aboutMe</code> 中找不到</li><li>因此印出錯誤訊息 <code>Uncaught ReferenceError: age is not defined</code></li></ol><p><img src="https://imgur.com/W0ss9O1.jpg" alt="Ning-draw (8)"></p><p>為什麼不是往 <code>if (myName == &quot;Ning&quot;)</code><br>主要是因為 JavaScript 是採用 Lexical Scope 的方式，</p><blockquote><p>The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available.</p></blockquote><p>根據 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping">MDN</a> 的解釋，Lexical Scope 會取決於該程式碼的 <code>所在位置</code>，而非程式碼的 <code>執行位置</code></p><p>也就是說，我們要看的是 <code>myAge</code> 位在於程式碼的哪裡，並且去找到他的父層，而他的父層就是 <code>aboutMe</code>，</p><p>因此 <code>reference to outer environment</code> 這個倉庫也只會放 <code>aboutMe</code> 的變數</p><p>看到這邊應該有個疑惑，為什麼 <code>if (myName == &quot;Ning&quot;)</code> 的 var 會被放在 <code>aboutMe</code> 的 <code>Variable Environment</code> ？</p><p>依照 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var">MDN</a> 的說明， var 只能被包在 <code>Function</code> 中，一旦出了 <code>Function</code> 這個作用域，就會變成 <code>Global</code> 作用域</p><p>關於 <code>Variable Environment</code> 的詳細介紹，將在下篇文章提出</p><p>參考<br><a href="https://www.borderlessengineer.com/p/how-js-works-understanding-the-execution">https://www.borderlessengineer.com/p/how-js-works-understanding-the-execution</a></p><p><a href="https://www.freecodecamp.org/news/javascript-execution-context-and-hoisting/">https://www.freecodecamp.org/news/javascript-execution-context-and-hoisting/</a></p><p><a href="https://www.frontendmag.com/tutorials/lexical-environment-in-javascript/">https://www.frontendmag.com/tutorials/lexical-environment-in-javascript/</a></p><p><a href="https://262.ecma-international.org/6.0/#sec-execution-contexts">https://262.ecma-international.org/6.0/#sec-execution-contexts</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping</a></p>]]></content>
    
    
    <summary type="html">JavaScript 運行背後到底做了哪些事，所謂的 Execution Context 又是什麼？</summary>
    
    
    
    <category term="JavaScript" scheme="http://ninglab.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Rails - Turbo 與 Turbo Drive</title>
    <link href="http://ninglab.com/Rails-Turbo-and-Turbo%20Drive/"/>
    <id>http://ninglab.com/Rails-Turbo-and-Turbo%20Drive/</id>
    <published>2024-03-03T17:53:18.000Z</published>
    <updated>2024-03-31T15:41:00.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Turbo"><a href="#Turbo" class="headerlink" title="Turbo"></a>Turbo</h1><h2 id="瀏覽器的載入模式"><a href="#瀏覽器的載入模式" class="headerlink" title="瀏覽器的載入模式"></a>瀏覽器的載入模式</h2><p>在 AJAX 還沒出現以前，使用者在瀏覽網頁，進行互動後，需要重新整理才會在網頁上看到互動後的結果</p><p><img src="https://i.imgur.com/CFwObAB.jpeg"></p><h2 id="AJAX-模式"><a href="#AJAX-模式" class="headerlink" title="AJAX 模式"></a>AJAX 模式</h2><p>AJAX 的全名為 Asynchronous JavaScript and XML ，這些字詞的意思為 非同步 JavaScript 與 XML</p><p>非同步 JavaScript 大家應該都不陌生，指的是不需要等待上一個任務執行完再執行下一個，因此系統同時可以處理多個任務</p><p>而 AJAX 使用 XMLHttpRequest 來發送 Request，格式是採用 XML 格式</p><p>回傳的 Response 可以採用 XML 或者是 JSON ，現階段大多以 JSON 格式回傳</p><p><img src="https://i.imgur.com/vxXZ5xN.jpeg"></p><p>如此一來，就能馬上渲染資料</p><p><img src="https://i.imgur.com/h0MzwaM.gif" alt="giphy"></p><p>讓我們用 JS 的角度來看一下 AJAX 會是怎麼發送的，就會比較好理解 Turbo 的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const button = document.getElementById(&quot;button&quot;)</span><br><span class="line"></span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  xhr.open(&#x27;GET&#x27;, &#x27;ajax.txt&#x27;, true);</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onload = function()&#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      let text = document.getElementById(&quot;text&quot;)</span><br><span class="line">      text.innerHTML = this.responseText</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其實原理跟一般的事件監聽很像，<br>差別在於 <code>XMLHttpRequest</code> 會透過 url 來獲取資料，<br>而 <code>xhr.open</code> 第三個參數指的是是否採取同步或非同步，<br><code>true</code> 表示採取非同步</p><p>所以後續的程式碼都會一起執行，<br>並且及時地將拿回來的 Response 資料渲染</p><h2 id="關於-Turbo"><a href="#關於-Turbo" class="headerlink" title="關於 Turbo"></a>關於 Turbo</h2><p>Rails 透過 Turbo 來加速網頁的載入速度，</p><p>Turbo 是 AJAX 技術的應用，但他做的事會比 AJAX 更多</p><p>而 Turbo 又分成幾個功能</p><ol><li><p>Turbo Drive<br>加速載入頁面，讓使用者感受不到頁面之間的切換</p></li><li><p>Turbo Frame<br>不需要寫大量的 DOM 元素就能在同樣的頁面渲染表單或資訊</p></li><li><p>Turbo Stream<br>透過 Action Cable 即時渲染 Response 的內容</p></li><li><p>Turbo Native<br>用 Turbo 來打造 App (不過目前尚未設略，暫時不介紹)</p></li></ol><p>今天我們會先介紹 Turbo Drive</p><h2 id="關於-Turbo-Drive"><a href="#關於-Turbo-Drive" class="headerlink" title="關於 Turbo Drive"></a>關於 Turbo Drive</h2><p>Turbo Drive 就是以前的 Turbolinks</p><p>用 Rails 寫過專案的人應該多少都遇過在點擊連結的時候完全沒作用，是因為 Turbolinks 把所有的連結預設事件都停掉了，在 Rails 5 ~ Rails 6 版本的專案，我們可以用 <code>data-turbo=&quot;false&quot;</code> 來停掉連結的 Turbolinks</p><p>而在 Rails 7 中， Turbo Drive 不只將連結的預設事件停掉，連表單的預設事件也被停掉了，這樣做的目的是為了提高載入的速度！</p><p>只要掌握 Turbo Drive 的原理，它就會很好用！</p><h3 id="從-Visit-開始的生命週期"><a href="#從-Visit-開始的生命週期" class="headerlink" title="從 Visit 開始的生命週期"></a>從 Visit 開始的生命週期</h3><p>在使用者點擊的那一刻， Turbo Drive 的生命週期就開始了，一直到 render 完頁面才結束</p><p>Turbo Drive 在 render 的時候會做以下這幾件事情</p><ol><li>將 body 換成 Response 的 body</li><li>如果 head 的 title 以及 meta 改變，會將 head 合併，反之，head 將保持原樣</li><li>有需要的話會將 html 的 lang 標籤更新</li><li>除此之外，還會將 URL 更換掉</li></ol><p>Turbo 會有幾個生命週期，</p><p><code>turbo:click</code><br><code>turbo:before-visit</code><br><code>turbo:visit</code><br><code>turbo:before-cache</code><br><code>turbo:before-render</code><br><code>turbo:render</code><br><code>turbo:load</code></p><p>我們先來看前置作業，當點擊連結，並且拜訪 URL 以前，忙碌的 Turbo 做了哪些事</p><h3 id="session-visit-Turbo-開始"><a href="#session-visit-Turbo-開始" class="headerlink" title="session.visit - Turbo 開始"></a>session.visit - Turbo 開始</h3><p>當點擊時， Turbo 會先去判斷是否為 turbo frame，不是的話就會去拜訪該 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:97</span><br><span class="line"></span><br><span class="line">visit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  const frameElement = options.frame ? document.getElementById(options.frame) : null</span><br><span class="line"></span><br><span class="line">  if (frameElement instanceof FrameElement) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.navigator.proposeVisit(expandURL(location), options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navigator-停止預設事件"><a href="#Navigator-停止預設事件" class="headerlink" title="Navigator - 停止預設事件"></a>Navigator - 停止預設事件</h3><p>開始導去 URL 的時候，會先判斷該 URL 是否為同一頁，或者不同頁但是觸發 <code>turbo:before-visit</code> 事件，並且把預設事件停掉，就會開始接下來的訪問</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:12</span><br><span class="line"></span><br><span class="line">proposeVisit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) &#123;</span><br><span class="line">    this.delegate.visitProposedToLocation(location, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session-開始拜訪"><a href="#Session-開始拜訪" class="headerlink" title="Session - 開始拜訪"></a>Session - 開始拜訪</h3><p>在這個階段會先將 URL 做新舊版本的轉換，避免舊版本無法支援(這邊的版本是指 Turbo Native 的 adapter)<br>接著就會請瀏覽器去拜訪了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:239</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  extendURLWithDeprecatedProperties(location)</span><br><span class="line">  this.adapter.visitProposedToLocation(location, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Browser-Adapter-拜訪前的敲門鈴確認"><a href="#Browser-Adapter-拜訪前的敲門鈴確認" class="headerlink" title="Browser Adapter - 拜訪前的敲門鈴確認"></a>Browser Adapter - 拜訪前的敲門鈴確認</h3><p>這時候 Turbo 會去確認 URL 的網域是不是一致的，一致才會繼續拜訪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:13</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  if (locationIsVisitable(location, this.navigator.rootLocation)) &#123;</span><br><span class="line">    this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    window.location.href = location.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navigator-點下連結後的導向"><a href="#Navigator-點下連結後的導向" class="headerlink" title="Navigator - 點下連結後的導向"></a>Navigator - 點下連結後的導向</h3><p>在導向新的 URL 時，就會透過 expendURL 將 URL 設定成新的，不過不是在這邊換掉，是在 Visit 開始的時候才會換掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:18</span><br><span class="line"></span><br><span class="line">startVisit(locatable, restorationIdentifier, options = &#123;&#125;) &#123;</span><br><span class="line">  this.stop()</span><br><span class="line">  this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, &#123;</span><br><span class="line">    referrer: this.location,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;)</span><br><span class="line">  this.currentVisit.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// src/core/url.js:1</span><br><span class="line"></span><br><span class="line">export function expandURL(locatable) &#123;</span><br><span class="line">  return new URL(locatable.toString(), document.baseURI)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Visit-Turbo-Drive-開始生效"><a href="#Visit-Turbo-Drive-開始生效" class="headerlink" title="Visit - Turbo Drive 開始生效"></a>Visit - Turbo Drive 開始生效</h3><p>當確認好狀態為 <code>initialized</code> 並且定義完基本設定後，就會開始了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:117</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">  if (this.state == VisitState.initialized) &#123;</span><br><span class="line">    this.recordTimingMetric(TimingMetric.visitStart)</span><br><span class="line">    this.state = VisitState.started</span><br><span class="line">    this.adapter.visitStarted(this)</span><br><span class="line">    this.delegate.visitStarted(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Browser-Adapter-改頭換面的開始"><a href="#Browser-Adapter-改頭換面的開始" class="headerlink" title="Browser Adapter - 改頭換面的開始"></a>Browser Adapter - 改頭換面的開始</h3><p>當開始 Visit 時，第一件事會將 URL 換掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:21</span><br><span class="line"></span><br><span class="line">visitStarted(visit) &#123;</span><br><span class="line">  this.location = visit.location</span><br><span class="line">  visit.loadCachedSnapshot()</span><br><span class="line">  visit.issueRequest()</span><br><span class="line">  visit.goToSamePageAnchor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著 Turbo Drive 需要判斷連結有沒有在 Cached 中，有的話就會直接渲染 Cached 中的頁面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:247</span><br><span class="line"></span><br><span class="line">loadCachedSnapshot() &#123;</span><br><span class="line">  const snapshot = this.getCachedSnapshot()</span><br><span class="line">  if (snapshot) &#123;</span><br><span class="line">    const isPreview = this.shouldIssueRequest()</span><br><span class="line">    this.render(async () =&gt; &#123;</span><br><span class="line">      this.cacheSnapshot()</span><br><span class="line">      if (this.isSamePage || this.isPageRefresh) &#123;</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.view.renderPromise) await this.view.renderPromise</span><br><span class="line"></span><br><span class="line">        await this.renderPageSnapshot(snapshot, isPreview)</span><br><span class="line"></span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">        if (!isPreview) &#123;</span><br><span class="line">          this.complete()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著會去看 Cached 是否已經有 Response ，<br>有的話就會模擬之前的 Request ，<br>沒有的話就會發送一個新的 Request</p><p>為什麼可以先載入 Response ，可參考此 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/preloadResponse">MDN 的說明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:166</span><br><span class="line"></span><br><span class="line">issueRequest() &#123;</span><br><span class="line">  if (this.hasPreloadedResponse()) &#123;</span><br><span class="line">    this.simulateRequest()</span><br><span class="line">  &#125; else if (this.shouldIssueRequest() &amp;&amp; !this.request) &#123;</span><br><span class="line">    this.request = new FetchRequest(this, FetchMethod.get, this.location)</span><br><span class="line">    this.request.perform()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再來就是判斷新 URL 跟目前所在的頁面是否為同一頁，<br>同一頁的話就會挪到指定的 Anchor </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:281</span><br><span class="line"></span><br><span class="line">  goToSamePageAnchor() &#123;</span><br><span class="line">    if (this.isSamePage) &#123;</span><br><span class="line">      this.render(async () =&gt; &#123;</span><br><span class="line">        this.cacheSnapshot()</span><br><span class="line">        this.performScroll()</span><br><span class="line">        this.changeHistory()</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Session-拜訪"><a href="#Session-拜訪" class="headerlink" title="Session - 拜訪"></a>Session - 拜訪</h3><p>接著</p><p>假設目前的 Visit 並沒有接受 Stream 格式的 Response ，就將它標記為正在處理中，這個處理可能是在處理 Request 以及換頁，</p><p>總之，不是以 Turbo Drive 的方式去處理</p><p>接著會判斷是在看是不是為同一頁，同一頁的話就會觸發 <code>turbo:visit</code> 並訪問該 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:246</span><br><span class="line"></span><br><span class="line">  visitStarted(visit) &#123;</span><br><span class="line">    if (!visit.acceptsStreamResponse) &#123;</span><br><span class="line">      markAsBusy(document.documentElement)</span><br><span class="line">      this.view.markVisitDirection(visit.direction)</span><br><span class="line">    &#125;</span><br><span class="line">    extendURLWithDeprecatedProperties(visit.location)</span><br><span class="line">    if (!visit.silent) &#123;</span><br><span class="line">      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上只是渲染之前所做的事情 ( 實際上要處理的應該遠比我提的更多，我這邊只先提個大致的流程 )</p><h3 id="不同的-Visit"><a href="#不同的-Visit" class="headerlink" title="不同的 Visit"></a>不同的 Visit</h3><p>Turbo Drive 又分成兩種 Visit</p><p>一種是 <code>Application Visits</code> ，另一種是 <code>Restoration Visits</code></p><p>在這之前我們可以來了解一下 Turbo Drive 處理 Cached 的機制</p><p>Turbo Drive 會將最近造訪過的 URL 暫存，有兩個目的</p><ol><li>在歷史紀錄中切換 URL ( 即所謂的 Restoration Visits  ) 的時候，不需要發送 Request 就能渲染</li><li>在一般的 URL 切換中，能快速渲染頁面(但還是會發送 Request)，讓使用者感受不到有在切換</li></ol><p>Application Visits 將會發送 Request ，並且如果 Cached 有該 URL 頁面資訊的話，就會渲染頁面資訊</p><p>Restoration Visits<br>使用者點擊了瀏覽器的上一頁，或是下一頁，因為已經瀏覽過， Cached 中可能會有資料，所以就不會發送 Request ，而是直接 render Cached 裡面的頁面資訊</p><p>上述兩種 Visit 最大的差別應該是在於是否為歷史紀錄中的切換以及是否有發送 Request</p>]]></content>
    
    
    <summary type="html">使用 Rails 7 ，Turbo 讓你的網頁比別人更快</summary>
    
    
    
    <category term="Rails" scheme="http://ninglab.com/categories/Rails/"/>
    
    
  </entry>
  
  <entry>
    <title>工程師都該懂的程式通識 - Proxy</title>
    <link href="http://ninglab.com/proxy/"/>
    <id>http://ninglab.com/proxy/</id>
    <published>2024-02-22T15:07:31.000Z</published>
    <updated>2024-02-23T17:41:45.516Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家從小到大應該都會碰到代理伺服器，代理伺服器就像是我們生活中的代理人一樣，會代表著 Client 端或者 Server 端</p><p>我們就來進入正題吧</p><h3 id="什麼是代理伺服器"><a href="#什麼是代理伺服器" class="headerlink" title="什麼是代理伺服器"></a>什麼是代理伺服器</h3><p>在 10 年前，大家點開 ie 的頁面都是 Yahoo ，</p><p>網路速度不比現在，都需要等個一兩分鐘，</p><p>等個一兩次還好，不過等太多次難免會覺得很煩，</p><p>每次點開都需要重新發送請求，然後再等一次</p><p><img src="https://hackmd.io/_uploads/HyojT_VPa.jpg" alt="Ning-draw (7)"></p><p>這時候代理伺服器就出現了，代理伺服器就像是班代的角色，</p><p>會代替使用者去跟 Server 端發送請求，</p><p>並且將要來的資料在自己身上暫存一份，</p><p>等到下個使用者再來請求的時候，就將這份暫存提供給他</p><p><img src="https://hackmd.io/_uploads/BJW6Ad4Pa.jpg" alt="Ning-draw (8)"></p><p>理解了什麼是代理伺服器的概念後，</p><p>我們來看正向代理伺服器跟反向代理伺服器就會簡易許多</p><h3 id="正向代理伺服器-Forward-Proxy"><a href="#正向代理伺服器-Forward-Proxy" class="headerlink" title="正向代理伺服器 Forward Proxy"></a>正向代理伺服器 Forward Proxy</h3><p>正向代理伺服器就跟我們上面提到的代理伺服器是一樣的概念，</p><p>代表 Client 端跟網路發送請求，網路會再將請求傳送給 Server</p><p><img src="https://hackmd.io/_uploads/HyfOiKEDa.jpg" alt="Ning-draw (9)"></p><p>我們用個簡單的例子來說明：</p><p>當考試成績出來後，學生都要一個一個去找老師拿成績單，</p><p>不過一個一個去拿其實蠻麻煩而且沒有效率</p><p>這時候我們就可以推派班代去代替整班的學生跟老師拿成績單</p><h4 id="生活中的應用"><a href="#生活中的應用" class="headerlink" title="生活中的應用"></a>生活中的應用</h4><ol><li>限制能連線的網站：</li></ol><p>以前我們在上電腦課的時候，會想要偷偷連到遊戲網站上玩遊戲，</p><p>不過學校沒有那麼笨，在學校內的電腦，都會設定防火牆，</p><p>當防火牆有設定限制存取的網站，甚至是限制代理伺服器時，</p><p>我們就很難繞過這一層去遊戲網站了</p><p><img src="https://hackmd.io/_uploads/rkaUPuEva.jpg" alt="Ning-draw (2)"></p><ol start="2"><li>保護使用者的資料</li></ol><p>當使用者去瀏覽網站時，網站是可以存取到使用者的資訊的，</p><p>有了代理伺服器這個角色，使用者會透過代理伺服器去發送請求、接受回應，</p><p>所以網站只能知道代理伺服器的資料，並不會知道使用者的資料</p><p><img src="https://hackmd.io/_uploads/ByPOu_Ev6.jpg" alt="Ning-draw (3)"></p><h3 id="反向代理伺服器"><a href="#反向代理伺服器" class="headerlink" title="反向代理伺服器"></a>反向代理伺服器</h3><p>跟正向代理伺服器相反，反向代理伺服器代表的對象就會是 Server 端</p><p><img src="https://hackmd.io/_uploads/HyJEdDVwT.jpg" alt="Ning-draw (1)"></p><p>我們用簡單的例子來說：</p><p>今天有一群人想跟政府陳情，這時候他們的請求會送給代表人，</p><p>代表人會再將這些請求丟給政府的各個機關</p><p>等各個政府機關決議好後，就會將結果傳送給代表人</p><p>由代表人告訴民眾結果</p><h4 id="生活中的應用-1"><a href="#生活中的應用-1" class="headerlink" title="生活中的應用"></a>生活中的應用</h4><ol><li>保護 server</li></ol><p>當 Server 的資訊赤裸的公開時，難免會受到攻擊，</p><p>而反向代理伺服器的角色就能當作 Server 端的擋箭牌，</p><p>避免 Server 端被攻擊</p><p><img src="https://hackmd.io/_uploads/SJ-7juNDT.jpg" alt="Ning-draw (5)"></p><ol start="2"><li>平衡負載</li></ol><p>熱門網站像是 Google 、 Amazon ，一天可能會有上千萬名使用者進站</p><p>只有一個 Server 是不可能負荷得了短時間內有上萬個使用者</p><p>所以一次應該都會有多台 Server 在跑，</p><p>而代理伺服器的角色就會像是交通指揮，指揮哪些請求要去哪個 Server 避免 Server 崩潰</p><p><img src="https://hackmd.io/_uploads/ByUI9dNvp.jpg" alt="Ning-draw (4)"></p><ol start="3"><li>代理 SSL</li></ol><p>當 Client 端發送請求出去後，需要經過 SSL 握手，確保雙方的身份是對的才可以進行下一步</p><p>反向代理伺服器就會幫 Server 充當代理，將加密過的 SSL 訊息解密，之後就會放行請求給 Server</p><p><img src="https://hackmd.io/_uploads/ry7aiu4Pp.jpg" alt="Ning-draw (6)"></p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>當我們今天要瀏覽的網站是美國的網站，可能這網站的伺服器放在美國，</p><p>地區遙遠的關係會讓我們在存取的時間上拉長，為了把時間花在同一件事上(每次發送請求都要美國的伺服器拿資料)，代理伺服器會將資料快取起來，</p><p>不管是正向代理伺服器還是反向代理伺服器，這兩種類都會提供資料快取，</p><p>會先將資料暫存在代理伺服器中，等到其他使用者需要存取相同的資料時，就會派上用場</p><p>而資料只會暫存一段時間，過一段時間就會消除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信大家從小到大應該都會碰到代理伺服器，代理伺服器就像是我們生活中的代理人一樣，會代表著 Client 端或者 Server 端&lt;/p&gt;
&lt;p&gt;我們就來進入正題吧&lt;/p&gt;
&lt;h3 id=&quot;什麼是代理伺服器&quot;&gt;&lt;a href=&quot;#什麼是代理伺服器&quot; class=&quot;header</summary>
      
    
    
    
    <category term="程式通識" scheme="http://ninglab.com/categories/%E7%A8%8B%E5%BC%8F%E9%80%9A%E8%AD%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - 什麼是 Compose</title>
    <link href="http://ninglab.com/Docker-compose-yaml-file/"/>
    <id>http://ninglab.com/Docker-compose-yaml-file/</id>
    <published>2024-02-22T15:04:11.000Z</published>
    <updated>2024-02-23T17:46:27.635Z</updated>
    
    <content type="html"><![CDATA[<p>之前我們介紹了 Dockerfile 的基本指令，</p><p>這次的主題我們要來介紹 docker-compose.yml </p><h3 id="關於-docker-compose-yml"><a href="#關於-docker-compose-yml" class="headerlink" title="關於 docker-compose.yml"></a>關於 docker-compose.yml</h3><h4 id="是什麼？"><a href="#是什麼？" class="headerlink" title="是什麼？"></a>是什麼？</h4><p>官方的說明</p><blockquote><p>Compose is a tool for defining and running multi-container Docker applications. </p></blockquote><p>Compose 是運行多個 container 的工具。</p><p>什麼意思呢？</p><p>如果專案中需要跑多個 container 起來，</p><p>我們就需要使用到 Compose 把他們集結起來，組合成我們的專案。</p><p>用生活中的例子來說明，</p><p>某個工廠有四位成員，</p><p>這四個成員就像是每個 container 一樣，在工廠中付出勞力或心力，</p><p>而 Compose 就像是工廠，</p><p>將這四位成員集中起來，並且保持產線的運作</p><h4 id="什麼時候該用它？"><a href="#什麼時候該用它？" class="headerlink" title="什麼時候該用它？"></a>什麼時候該用它？</h4><blockquote><p>當我們的專案會同時跑多個 container 時，就會需要用到 compose</p></blockquote><p>舉例來說，用 Rails 寫的專案，</p><p>我們需要跑一個 <code>Ruby</code> container，</p><p>要用 <code>Postgresql</code> 作為資料庫的話，就會需要另外再跑一個 container </p><p>那如果不要用呢？</p><p>我們就要用指令一個一個設定 networks 是哪個，是否需要用 volumes </p><p>指令會變成一大串，聽起來其實蠻麻煩的吧</p><h4 id="docker-compose-yml-可以做什麼設定"><a href="#docker-compose-yml-可以做什麼設定" class="headerlink" title="docker-compose.yml 可以做什麼設定"></a>docker-compose.yml 可以做什麼設定</h4><p>docker-compose.yml 可以做很多設定，我們會透過這個檔案，告訴 Docker Compose 需要用哪些服務、要去監聽哪個 ports，甚至是設定環境變數</p><ul><li>version</li></ul><p>docker-compose.yml 是使用哪個版本</p><ul><li>services</li></ul><p>我們會設定這個專案會使用到哪些服務，例如由這個專案包起來的 image、資料庫的 image 等等</p><ul><li>platform</li></ul><p>如果我們要運行的機器是特定的作業系統，就必須在這邊做設定<br>還有一個情況是，假設我們本機的作業系統與機器作業系統不同，也需要設定這個參數</p><ul><li>ports</li></ul><p>Docker 會依照我們設定的 port ，來取決於 Docker 的哪個 port 要去監聽機器上的哪個 port</p><ul><li>environment</li></ul><p>我們也可以在 docker-compose.yml 中設定環境變數。</p><p>不過環境變數什麼時候該在 dockerfile 設定，什麼時候又該在 docker-compose.yml 設定？</p><p>取決於 dockerfile 這顆做出來的 image 是否要重複使用，且環境變數是否一致，一致的話就可以設定在 dockerfile 中，不一致的話我們就可以設定在 docker-compose.yml 中</p><ul><li>restart</li></ul><p>告訴 Docker 什麼時候開重新啟動</p><ul><li>networks</li></ul><p>告訴 Docker 這顆 contailer 是使用哪個 networks </p><ul><li>volumes</li></ul><p>告訴 Docker 這顆 contailer 存放的資料放在哪個 volumes </p><p>以上是我們在寫 docker-compose.yml 常用到的設定</p><p><code>networks</code> 、 <code>volumes</code> 我們將在之後會提到。</p><h3 id="撰寫-docker-compose-yml-檔案"><a href="#撰寫-docker-compose-yml-檔案" class="headerlink" title="撰寫 docker-compose.yml 檔案"></a>撰寫 docker-compose.yml 檔案</h3><p>接著我們來試做一個簡單的 <code>docker-compose.yml</code> 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: &quot;ruby:3.2.0-alpine3.17&quot;</span><br></pre></td></tr></table></figure><p>寫好 docker-compose.yml 後，我們將 image 跑起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose up</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 2/1</span><br><span class="line"> ⠿ Network ishop_default  Created                                                                      0.1s</span><br><span class="line"> ⠿ Container ishop-app-1  Created                                                                      0.0s</span><br><span class="line">Attaching to ishop-app-1</span><br><span class="line">ishop-app-1  | Switch to inspect mode.</span><br><span class="line">ishop-app-1  | </span><br><span class="line">ishop-app-1 exited with code 0</span><br></pre></td></tr></table></figure><h4 id="這個指令背後做了哪些事？"><a href="#這個指令背後做了哪些事？" class="headerlink" title="這個指令背後做了哪些事？"></a>這個指令背後做了哪些事？</h4><p>當我們下了 <code>docker compose up</code> 時， Docker 會先從 docker-compose.yml 解析，並且開始建立 image ，建立完成後就會跑 container</p><p>基本上就是 <code>build</code> + <code>run container</code> 的指令</p><p><img src="https://hackmd.io/_uploads/ryf5H6ff6.jpg"></p><p>那如果我們更新了專案，還要再重新跑一次指令嗎？</p><p>不需要， <code>docker compose</code> 會去查看哪個地方改了，會更新修改的地方並且 <code>recreate container</code></p><p><img src="https://hackmd.io/_uploads/r1NUnTzMT.jpg"></p><h3 id="將-container-停止"><a href="#將-container-停止" class="headerlink" title="將 container 停止"></a>將 container 停止</h3><p>當我們下完以下指令，他就會 stop 所有的 container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose stop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container ning_lab_blog-app-1       Stopped                                                                               0.4s</span><br><span class="line"> ⠿ Container ning_lab_blog-traefik-1   Stopped                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-database-1  Stopped                                                                               0.3s</span><br></pre></td></tr></table></figure><h3 id="將-Docker-Compose-中的-container-清理掉"><a href="#將-Docker-Compose-中的-container-清理掉" class="headerlink" title="將 Docker Compose 中的 container 清理掉"></a>將 Docker Compose 中的 container 清理掉</h3><p>如果我們要將所有 container 刪除，就可以使用這個指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose down</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container ning_lab_blog-app-1       Removed                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-traefik-1   Removed                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-database-1  Removed                                                                               0.0s</span><br></pre></td></tr></table></figure><p>什麼時候要用 docker compose stop 什麼時候要用 docker compose down ?</p><p><img src="https://hackmd.io/_uploads/SkXDn6MMa.jpg"></p><p>以我自己的習慣，如果只是要讓專案暫停，就會使用 <code>docker compose stop</code></p><p>但如果我今天是要重新建立 image 並且重跑，就會使用 <code>docker compose down</code> 請他將 Docker Compose 清乾淨</p><h3 id="將-image-建立並且跑起來"><a href="#將-image-建立並且跑起來" class="headerlink" title="將 image 建立並且跑起來"></a>將 image 建立並且跑起來</h3><p>其實這個指令跟 <code>docker compose up</code> 蠻像的，差別在於他會強制 <code>build image</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose up --build</span><br></pre></td></tr></table></figure><p>什麼時候要用 <code>docker compose up</code> 什麼時候要用 <code>docker compose up --build</code> ?</p><p>我也被這兩個指令搞混蠻久的，總結是</p><p><img src="https://hackmd.io/_uploads/ryjPhpzfT.jpg"></p><p>當我們在包 image 的時候，就會用 <code>docker compose up --build</code> 讓他強制重新建立 image </p><p>而 <code>docker compose up</code> 會偵測到專案更新的時候，會 recreate container ，所以通常用在已經不會再去改 image 只有修改專案內容的時候</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前我們介紹了 Dockerfile 的基本指令，&lt;/p&gt;
&lt;p&gt;這次的主題我們要來介紹 docker-compose.yml &lt;/p&gt;
&lt;h3 id=&quot;關於-docker-compose-yml&quot;&gt;&lt;a href=&quot;#關於-docker-compose-yml&quot; clas</summary>
      
    
    
    
    <category term="Docker" scheme="http://ninglab.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>工程師都該懂的程式通識 - 語言的分類</title>
    <link href="http://ninglab.com/language/"/>
    <id>http://ninglab.com/language/</id>
    <published>2024-02-22T15:03:48.000Z</published>
    <updated>2024-02-23T17:41:07.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直譯語言與編譯語言"><a href="#直譯語言與編譯語言" class="headerlink" title="直譯語言與編譯語言"></a>直譯語言與編譯語言</h2><p><img src="https://hackmd.io/_uploads/BJh7Pbnzp.jpg"></p><h3 id="直譯語言是什麼？"><a href="#直譯語言是什麼？" class="headerlink" title="直譯語言是什麼？"></a>直譯語言是什麼？</h3><p>簡單來說不是使用編譯器來編譯，而是使用解釋器邊讀取邊執行，像是 Ruby、Python、JavaScript 都是直譯語言</p><p>編譯期：並沒有明確的編譯期，由直譯語言的解釋器 (Interpreter)<br>進行編譯，可以一邊讀取一邊執行，讀取完後會執行該程式碼，並且檢查語法，解釋器 (Interpreter)<br>像是口譯員，在讀取完完整的句子後，翻譯出來</p><p>執行期：解釋器(Interpreter)在執行期會將指令轉換為電腦能懂的語言，並且處理輸入、輸出，而這時候進行錯誤檢查，像是型別錯誤、定義變數的錯誤都會在這時候出現</p><h3 id="編譯語言是什麼？"><a href="#編譯語言是什麼？" class="headerlink" title="編譯語言是什麼？"></a>編譯語言是什麼？</h3><p>會先將程式碼編譯，再進行執行，像是 C、C#、JAVA 都是編譯語言</p><p>編譯期：由編譯器(Compiler)編譯成電腦看得懂的機器碼，這時期就會去檢查語法、型別等錯誤</p><p>執行期：這個階段會進行執行</p><h3 id="直譯語言與編譯語言的差異"><a href="#直譯語言與編譯語言的差異" class="headerlink" title="直譯語言與編譯語言的差異"></a>直譯語言與編譯語言的差異</h3><h4 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h4><p>編譯語言通常會先經過編譯期，事先把程式碼編譯好再執行，</p><p>不過直譯語言是邊讀取邊執行，所以在效能上，編譯語言會比直譯語言快。</p><h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>直譯語言在 Debug 的時候會方便許多，因為不需要修改再下指令要求編譯並執行，且可以提供更詳細的錯誤訊息</p><p>不過目前有些編譯語言也會提供詳細的錯誤訊息，像是 Rust ，不過一樣需要下指令才會讓程式碼重跑編譯期跟執行期</p><h2 id="動態語言跟靜態語言"><a href="#動態語言跟靜態語言" class="headerlink" title="動態語言跟靜態語言"></a>動態語言跟靜態語言</h2><p><img src="https://hackmd.io/_uploads/r1pBPW3f6.jpg"></p><h4 id="靜態語言"><a href="#靜態語言" class="headerlink" title="靜態語言"></a>靜態語言</h4><p>靜態語言指的是在編譯期間，型別就已經是已知且不會變動的，並且會在編譯期間檢查型別是否有誤，我們在編譯語言的編譯期可以看到型別錯誤的訊息，像是 Rust、C、C#、JAVA 都是靜態語言</p><h4 id="動態語言"><a href="#動態語言" class="headerlink" title="動態語言"></a>動態語言</h4><p>動態語言就跟靜態語言不一樣了，在執行的時候才會去檢查型別，表示變數的型別其實是可以在執行期變動的，像是 Ruby、PHP、JavaScript 都是動態語言</p><p>不過其實有些動態語言也支援編譯器，不過他們仍然被歸類在動態語言中，像是 Ruby 、Python 都可以將程式碼轉換成虛擬機器可以執行的程式碼</p><h2 id="高階語言與低階語言"><a href="#高階語言與低階語言" class="headerlink" title="高階語言與低階語言"></a>高階語言與低階語言</h2><p><img src="https://hackmd.io/_uploads/SJ2Uv-hMp.jpg"></p><p>而高階語言跟低階語言又是不同的分類，</p><h3 id="高階語言"><a href="#高階語言" class="headerlink" title="高階語言"></a>高階語言</h3><p>對於電腦來說比較抽象的語言，不過對開發人員來說是更富有易讀性，物件導向、高階資料結構這些都算是高階語言的特性</p><p>高階語言又根據特性分成以下類型</p><h4 id="通用程式語言"><a href="#通用程式語言" class="headerlink" title="通用程式語言"></a>通用程式語言</h4><p>用於處理各種不同類型的應用程式，可以適用網頁開發、軟體開發等多個領域，像是 Python、Java、C++、C#、Ruby、JavaScript</p><h4 id="腳本語言"><a href="#腳本語言" class="headerlink" title="腳本語言"></a>腳本語言</h4><p>通常用於簡化特定的指令、應用於自動化任務上，通常是直譯語言，像是 Python、JavaScript 等</p><h4 id="函數式語言"><a href="#函數式語言" class="headerlink" title="函數式語言"></a>函數式語言</h4><p>常用於大數據分析、數學運算，強調函數的不可變，像是 Haskell、Lisp、Scala、Erlang 等</p><h4 id="物件導向語言"><a href="#物件導向語言" class="headerlink" title="物件導向語言"></a>物件導向語言</h4><p>用物件來封裝，所應用到的大部分操作及變數都是物件，強調繼承概念，像是 Ruby、Java、C++、C#、Python 都是</p><h4 id="特定領域語言"><a href="#特定領域語言" class="headerlink" title="特定領域語言"></a>特定領域語言</h4><p>針對特定領域或任務所開發的語言，像是 HTML、SQL、CSS 都算是</p><h3 id="低階語言"><a href="#低階語言" class="headerlink" title="低階語言"></a>低階語言</h3><p>對於電腦來說更好閱讀的語言，對開發人員來說可能就沒這麼好閱讀，且開發人員需要注意記憶體管理，通常用於嵌入式系統開發、驅動程式開發，基本上是使用二進位形式</p><h4 id="組合語言"><a href="#組合語言" class="headerlink" title="組合語言"></a>組合語言</h4><p>相較二進位形式，更具有易讀性的語言，通常用符號來提高可讀性，可用來操作系統及驅動程式</p><h4 id="機器語言"><a href="#機器語言" class="headerlink" title="機器語言"></a>機器語言</h4><p>直接由 CPU 讀取及執行的指令，都是使用二進位形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;直譯語言與編譯語言&quot;&gt;&lt;a href=&quot;#直譯語言與編譯語言&quot; class=&quot;headerlink&quot; title=&quot;直譯語言與編譯語言&quot;&gt;&lt;/a&gt;直譯語言與編譯語言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJh7P</summary>
      
    
    
    
    <category term="程式通識" scheme="http://ninglab.com/categories/%E7%A8%8B%E5%BC%8F%E9%80%9A%E8%AD%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Rails 的預設環境變數存取方式 - Master Key</title>
    <link href="http://ninglab.com/Rails-Master-Key/"/>
    <id>http://ninglab.com/Rails-Master-Key/</id>
    <published>2024-02-22T15:03:03.000Z</published>
    <updated>2024-02-23T17:46:45.582Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rails 5.2 版本後，<br>Master key 就成了 Rails 內建的環境變數套件，用於管理環境變數</p><p>在 5.2 版本前， Rails 是使用 <code>config/secrets.yml</code> 或 <code>config/secrets.yml.erb</code> 來存取環境變數，且可以直接在任何環境中直接設定，無需針對特定環境做一個檔案，加上進版控後就會造成機密資料外洩的問題，因此後來拿掉了。</p><p>相較於我們常用的 dotenv ， master key 相對嚴謹的多</p><h3 id="運作原理"><a href="#運作原理" class="headerlink" title="運作原理"></a>運作原理</h3><p>我們可以將 <code>master.key</code> 想像成只有你擁有的鑰匙，鑰匙只能開啟你的保險箱 <code>credentials.yml.enc</code></p><p><code>master.key</code> 可以用來解密 <code>credentials.yml.enc</code>，但應該避免分享 master.key 或放進版控中，就像你不會把你家鑰匙給陌生人一樣</p><p><img src="https://hackmd.io/_uploads/HySD3SOF3.jpg"></p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>建立一個新的 Rails 應用程式時，會自動生成一個 master.key</p><p>在執行命令之前，需要設置編輯器 EDITOR，跟你的環境說該開哪個編輯器：</p><p><code>export EDITOR=&quot;code&quot;</code></p><p>我們來下指令編輯環境變數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=&quot;code --wait&quot; bin/rails credentials:edit</span><br></pre></td></tr></table></figure><p>假設你對於 vim 比較熟悉，就用 vim 來開啟吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=&quot;vim&quot; bin/rails credentials:edit</span><br></pre></td></tr></table></figure><p>會打開一個 yaml 檔案：</p><p><img src="https://hackmd.io/_uploads/rJoTcSdKh.png"></p><ul><li>secret_key_base: 用於加密和解密像是 cookie 這樣的機密數據</li></ul><p>在這個文件中，將你的環境變數加進去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># credential.yml</span><br><span class="line"></span><br><span class="line">aws:</span><br><span class="line">  access_key_id: 123</span><br><span class="line">  secret_access_key: 345</span><br></pre></td></tr></table></figure><p>設定完就可以儲存並關閉</p><p>要驗證環境變數是否已正確存入，可以使用以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails credentials:show</span><br></pre></td></tr></table></figure><p>如果設置正確，Rails 會生成一個 credential.yml.enc 文件，並且你會得到以下結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws:</span><br><span class="line">  access_key_id: 123</span><br><span class="line">  secret_access_key: 345</span><br><span class="line"></span><br><span class="line"># 用作 Rails 中所有 MessageVerifiers 的基本密鑰，包括保護 cookie 的密鑰。</span><br><span class="line">secret_key_base: dfcfa5ca64218b13d1dbf61745e420daea8ffeeef2a41eb8498c2378deb3bdbca91d5752ea97944f1a37b4458f7e7d535b91eef337010be67e664463e6e9457f</span><br></pre></td></tr></table></figure><p>如果需要在 Rails 中存取環境變數，可以用這個方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.credentials.aws.access_key_id</span><br></pre></td></tr></table></figure><h2 id="English-Version"><a href="#English-Version" class="headerlink" title="English Version"></a>English Version</h2><p>Master Key is a tool used for managing environment variables in Rails applications.<br>It has been the default method for handling sensitive data since Rails 5.2.</p><p>Before Master Key, Rails used the <code>config/secrets.yml</code> or <code>config/secrets.yml.erb</code> to store sensitive information, but this method had security problems.</p><h2 id="How-is-Master-Key-working？"><a href="#How-is-Master-Key-working？" class="headerlink" title="How is Master Key working？"></a>How is Master Key working？</h2><p>We can image the <code>master.key</code> file as a key that only you have, and <code>credentials.yml.enc</code> as a security box that stores valuable assets.</p><p>The <code>master.key</code> can open the encrypted <code>credentials.yml.enc</code> file, <code>master.key</code> file should not be shared or included in GitHub version control, just like you wouldn’t give your house key to a stranger for security reasons.</p><p><img src="https://hackmd.io/_uploads/HySD3SOF3.jpg"></p><h2 id="How-to-store-confidential-data-using-Master-Key？"><a href="#How-to-store-confidential-data-using-Master-Key？" class="headerlink" title="How to store confidential data using Master Key？"></a>How to store confidential data using Master Key？</h2><p>A <code>master.key</code> file is generated when creating a new rails application.</p><p>You can edit it using the command below:</p><ul><li>you need to set EDITOR as a key and pair the value with the code before, <code>export EDITOR=&quot;code&quot;</code>.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=&quot;code --wait&quot; bin/rails credentials:edit</span><br></pre></td></tr></table></figure><p>If you prefer using Vim instead of Visual Studio Code, you can use this command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=&quot;vim&quot; bin/rails credentials:edit</span><br></pre></td></tr></table></figure><p>This command opens the credential file, inside the file, you’ll see a YAML structure:</p><p><img src="https://hackmd.io/_uploads/HJuRcSuY2.png"></p><p>Let’s take a look at the <code>secret_key_base</code>, which is used to encrypt and decrypt confidential data like cookies.</p><p>Put your key-value pairs for an environment variable in this file, for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># credential.yml</span><br><span class="line"></span><br><span class="line">aws:</span><br><span class="line">  access_key_id: 123</span><br><span class="line">  secret_access_key: 345</span><br></pre></td></tr></table></figure><p>Once you added environment variables, save and close the file.</p><p>To verify the environment variables were saved correctly, you can use the following command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails credentials:show</span><br></pre></td></tr></table></figure><p>if everything was set up correctly, Rails will generate a <code>credential.yml.enc</code> file, and you’ll get the result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws:</span><br><span class="line">  access_key_id: 123</span><br><span class="line">  secret_access_key: 345</span><br><span class="line"></span><br><span class="line"># Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.</span><br><span class="line">secret_key_base: dfcfa5ca64218b13d1dbf61745e420daea8ffeeef2a41eb8498c2378deb3bdbca91d5752ea97944f1a37b4458f7e7d535b91eef337010be67e664463e6e9457f</span><br></pre></td></tr></table></figure><p>Now, if you need to access an environment variable within your Rails application, you can use the following code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.credentials.aws.access_key_id</span><br></pre></td></tr></table></figure><p>Congratulations on successfully setting up the environment variable through Master Key!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Rails 5.2 版本後，&lt;br&gt;Master key 就成了 Rails 內建的環境變數套件，用於管理環境變數&lt;/p&gt;
&lt;p&gt;在 5.2 版本前， Rails 是使用 &lt;code&gt;config/secrets.yml&lt;/code&gt; 或 &lt;code&gt;config/se</summary>
      
    
    
    
    <category term="Rails" scheme="http://ninglab.com/categories/Rails/"/>
    
    
  </entry>
  
  <entry>
    <title>叫我套件王 - 會員系統 Devise【1】</title>
    <link href="http://ninglab.com/Rails-Devise-1/"/>
    <id>http://ninglab.com/Rails-Devise-1/</id>
    <published>2024-02-22T15:02:40.000Z</published>
    <updated>2024-02-23T17:45:29.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="為什麼要用-Devise"><a href="#為什麼要用-Devise" class="headerlink" title="為什麼要用 Devise"></a>為什麼要用 Devise</h3><p> 支援多種會員系統模組<br> 有許多方便的方法</p><p>前置作業：</p><ul><li>建立一個 rails 專案 (本文章使用 7 版本)</li><li>安裝 <a href="https://github.com/heartcombo/devise">devise gem</a></li></ul><p>那我們就進入正題！</p><h4 id="Step-1-把-devise-安裝起來"><a href="#Step-1-把-devise-安裝起來" class="headerlink" title="Step 1 把 devise 安裝起來"></a>Step 1 把 devise 安裝起來</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle add devise</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails generate devise:install</span><br></pre></td></tr></table></figure><p>這個指令會幫初始化 devise 跟產出 devise 的 i18n yml 設定檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create  config/initializers/devise.rb</span><br><span class="line">create  config/locales/devise.en.yml</span><br></pre></td></tr></table></figure><p>會跳一大串的英文，不外乎就是在跟你說基本的設定等等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Depending on your application&#x27;s configuration some manual setup may be required:</span><br><span class="line"></span><br><span class="line">  1. Ensure you have defined default url options in your environments files. Here</span><br><span class="line">     is an example of default_url_options appropriate for a development environment</span><br><span class="line">     in config/environments/development.rb:</span><br><span class="line"></span><br><span class="line">       config.action_mailer.default_url_options = &#123; host: &#x27;localhost&#x27;, port: 3000 &#125;</span><br><span class="line"></span><br><span class="line">     In production, :host should be set to the actual host of your application.</span><br><span class="line"></span><br><span class="line">     * Required for all applications. *</span><br><span class="line"></span><br><span class="line">  2. Ensure you have defined root_url to *something* in your config/routes.rb.</span><br><span class="line">     For example:</span><br><span class="line"></span><br><span class="line">       root to: &quot;home#index&quot;</span><br><span class="line">     </span><br><span class="line">     * Not required for API-only Applications *</span><br><span class="line"></span><br><span class="line">  3. Ensure you have flash messages in app/views/layouts/application.html.erb.</span><br><span class="line">     For example:</span><br><span class="line"></span><br><span class="line">       &lt;p class=&quot;notice&quot;&gt;&lt;%= notice %&gt;&lt;/p&gt;</span><br><span class="line">       &lt;p class=&quot;alert&quot;&gt;&lt;%= alert %&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">     * Not required for API-only Applications *</span><br><span class="line"></span><br><span class="line">  4. You can copy Devise views (for customization) to your app by running:</span><br><span class="line"></span><br><span class="line">       rails g devise:views</span><br><span class="line">       </span><br><span class="line">     * Not required *</span><br></pre></td></tr></table></figure><p>devise 的安裝就大概完成囉</p><h4 id="Step-2-用-devise-產出-model"><a href="#Step-2-用-devise-產出-model" class="headerlink" title="Step 2 用 devise 產出 model"></a>Step 2 用 devise 產出 model</h4><p>如果今天 model 想叫 admin 或其他的，直接把 <code>User</code> 的地方改 <code>Admin</code> 或其他名字就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails generate devise User</span><br></pre></td></tr></table></figure><p>這個指令幫我們做出了 routes 及 model 及 migration 以及測試檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">invoke  active_record</span><br><span class="line">create  db/migrate/20230430165603_devise_create_users.rb</span><br><span class="line">create  app/models/user.rb</span><br><span class="line">invoke  test_unit</span><br><span class="line">create  test/models/user_test.rb</span><br><span class="line">create  test/fixtures/users.yml</span><br><span class="line">insert  app/models/user.rb</span><br><span class="line">route  devise_for :users</span><br></pre></td></tr></table></figure><p>我們可以來看一下 user.rb 這個檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Include default devise modules. Others available are:</span><br><span class="line"># :confirmable, :lockable, :timeoutable, :trackable and :omniauthable</span><br><span class="line">devise :database_authenticatable, :registerable,</span><br><span class="line">       :recoverable, :rememberable, :validatable</span><br></pre></td></tr></table></figure><p>devise 除了做出基本的會員註冊、登入功能，還包含了多種功能，依序介紹一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">confirmable: 發送註冊驗證信，並且在登入的時候，驗證使用者是否已經透過信件驗證</span><br><span class="line">lockable: 在登入失敗幾次後，會將使用者帳號鎖住</span><br><span class="line">timeoutable: 在一段時間內使用者沒有活動紀錄，就中止此 session</span><br><span class="line">trackable: 追蹤登入次數、時間及 IP 位置</span><br><span class="line">omniauthable: 第三方登入設定</span><br><span class="line">database_authenticatable: 針對密碼加密及儲存，會在使用者登入的時候做驗證</span><br><span class="line">registerable: 處理使用者的註冊流程，另外也提供編輯、刪除功能</span><br><span class="line">recoverable: 重設密碼功能</span><br><span class="line">rememberable: 透過 cookie 的資料來設定「記住我」</span><br><span class="line">validatable: 提供信箱及密碼的驗證機制，也可以另外自訂驗證</span><br></pre></td></tr></table></figure><p>假設我們今天要使用 confirmable 功能，那就必須把 :confirmable 解除註解，並且加到 <code>devise</code> 後方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Include default devise modules. Others available are:</span><br><span class="line"># :lockable, :timeoutable, :trackable and :omniauthable</span><br><span class="line">devise :database_authenticatable, :registerable,</span><br><span class="line">            :recoverable, :rememberable, :validatable, :confirmable</span><br></pre></td></tr></table></figure><p>在做 migration 以前，也要將 migration 的 :confirmable 解除註解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># db/migrate/20230701155654_devise_create_users.rb</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    # Confirmable</span><br><span class="line">    t.string   :confirmation_token</span><br><span class="line">    t.datetime :confirmed_at</span><br><span class="line">    t.datetime :confirmation_sent_at</span><br><span class="line">    t.string   :unconfirmed_email # Only if using reconfirmable</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>設定完成後我們就可以 migrate 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails db:migrate</span><br></pre></td></tr></table></figure><p>然後重啟 server</p><h3 id="試試-Devise-的基本註冊功能"><a href="#試試-Devise-的基本註冊功能" class="headerlink" title="試試 Devise 的基本註冊功能"></a>試試 Devise 的基本註冊功能</h3><p>先來檢視一下 devise 為我們做出來的路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails routes -c devise</span><br></pre></td></tr></table></figure><p>注意這邊要用 devise 才會顯示出 devise 做出來的路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                  Prefix Verb   URI Pattern                    Controller#Action</span><br><span class="line">        new_user_session GET    /users/sign_in(.:format)       devise/sessions#new</span><br><span class="line">            user_session POST   /users/sign_in(.:format)       devise/sessions#create</span><br><span class="line">    destroy_user_session DELETE /users/sign_out(.:format)      devise/sessions#destroy</span><br><span class="line">       new_user_password GET    /users/password/new(.:format)  devise/passwords#new</span><br><span class="line">      edit_user_password GET    /users/password/edit(.:format) devise/passwords#edit</span><br><span class="line">           user_password PATCH  /users/password(.:format)      devise/passwords#update</span><br><span class="line">                         PUT    /users/password(.:format)      devise/passwords#update</span><br><span class="line">                         POST   /users/password(.:format)      devise/passwords#create</span><br><span class="line">cancel_user_registration GET    /users/cancel(.:format)        devise/registrations#cancel</span><br><span class="line">   new_user_registration GET    /users/sign_up(.:format)       devise/registrations#new</span><br><span class="line">  edit_user_registration GET    /users/edit(.:format)          devise/registrations#edit</span><br><span class="line">       user_registration PATCH  /users(.:format)               devise/registrations#update</span><br><span class="line">                         PUT    /users(.:format)               devise/registrations#update</span><br><span class="line">                         DELETE /users(.:format)               devise/registrations#destroy</span><br><span class="line">                         POST   /users(.:format)               devise/registrations#create</span><br></pre></td></tr></table></figure><p>接下來我們可以直接到會員註冊的路徑了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/users/sign_up</span><br></pre></td></tr></table></figure><p>貼到瀏覽器中會出現以下畫面</p><p><img src="https://i.imgur.com/y6RCOqN.png"></p><p>輸入註冊的 Email 及密碼就能註冊成功囉！</p><h3 id="devise-幫你做的方法"><a href="#devise-幫你做的方法" class="headerlink" title="devise 幫你做的方法"></a>devise 幫你做的方法</h3><p>Devise 有做出一些 controller 及 view 常見的方法<br>需要注意的是，假設 model 是 <code>Admin</code>，請記得要把方法的 <code>_user</code> 改成 <code>_admin</code> ，其他依此類推</p><h4 id="Controller-action"><a href="#Controller-action" class="headerlink" title="Controller action"></a>Controller action</h4><p>舉例來說，假設我們的網站是使用者登入才可以使用，我們可以在 application controller 中加入 <code>before_action :authenticate_user!</code><br>設定後，使用者要進入所有頁面前都需要先登入</p><h4 id="View-helper"><a href="#View-helper" class="headerlink" title="View helper"></a>View helper</h4><p>如果頁面中有特定區塊是使用者登入才看得到的，我們可以加入 <code>user_sign_in?</code> 在 view 裡面我們可以這樣寫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if user_signed_in? %&gt;</span><br><span class="line">    已登入使用者才能看到的區塊</span><br><span class="line">&lt;% end %&gt;</span><br></pre></td></tr></table></figure><p>另一個更常見的 helper 是 <code>current_user</code><br>如果我們今天要在 view 顯示每個 user 的 email，就可以在 view 裡這樣寫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= current_user.email %&gt;</span><br></pre></td></tr></table></figure><p>還有其他方法，要使用的話可以直接至 Devise 手冊翻閱<br>今天的介紹內容相對簡單，下一篇我們再繼續挖深一點！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;為什麼要用-Devise&quot;&gt;&lt;a href=&quot;#為什麼要用-Devise&quot; class=&quot;headerlink&quot; title=&quot;為什麼要用 Devise&quot;&gt;&lt;/a&gt;為什麼要用 Devise&lt;/h3&gt;&lt;p&gt; 支援多種會員系統模組&lt;br&gt; 有許多方便的方法&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Rails" scheme="http://ninglab.com/categories/Rails/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - Dockerfile 基本介紹及指令</title>
    <link href="http://ninglab.com/Docker-Dockerfile-and-basic-command-2/"/>
    <id>http://ninglab.com/Docker-Dockerfile-and-basic-command-2/</id>
    <published>2024-02-22T15:02:14.000Z</published>
    <updated>2024-02-23T17:46:31.848Z</updated>
    
    <content type="html"><![CDATA[<p>我們在先前文章提過，Dockerfile 是我們用來建立 Image 的檔案 </p><p>我們可以把 Dockerfile 想像成是千層蛋糕 每一層為一個 Layer Image 就是層層堆疊後的千層蛋糕 </p><p><img src="https://i.imgur.com/ZTNfcdt.jpg"> </p><p>讓我們來看一下 DockerHub 裡的 Ruby 按到 Tags 頁籤，任意按一個版號進去，</p><p>就會看到像是歷史紀錄的畫面，這就是 Dockerfile 跑出來的層層 Layer </p><p>到這邊應該還是難想像，我們來動手建立一個 Dockerfile 應該就會比較好理解 </p><p><img src="https://i.imgur.com/GSspiC9.png"> </p><p>我們來依序介紹 Dockerfile 的指令，並且邊按照下列步驟練習 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 用什麼語言寫的，AS node 可以當作是貼上一個貼紙 </span><br><span class="line">FROM node:14-alpine AS node </span><br><span class="line"></span><br><span class="line"># 稍後會需要 yarn install，所以先安裝 yarn </span><br><span class="line">RUN apk add --no-cache yarn </span><br><span class="line"></span><br><span class="line"># 建立資料夾，可放入我們需要的檔案，或者在此執行 </span><br><span class="line">WORKDIR /app </span><br><span class="line"></span><br><span class="line"># 複製 package.json 及 yarn.lock 到 /app 這個資料夾下 </span><br><span class="line">COPY package.json yarn.lock /app/ </span><br><span class="line"></span><br><span class="line"># 有 package.json 及 yarn.lock，就可以先把套件裝起來了！ </span><br><span class="line">RUN yarn install </span><br><span class="line"></span><br><span class="line"># 套件安裝完畢，把所有檔案複製到 /app 中 </span><br><span class="line">COPY . /app </span><br><span class="line"></span><br><span class="line"># 將 host 的 port 指向 Image 中 Node.js 的 port </span><br><span class="line">EXPOSE 9229:9229 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是針對一個由 Node.js 寫的專案建立的 Dockerfile </p><p>基本上就是把我們平常架起環境的步驟 只是會再切分的細一點 </p><p>還有一些指令我們還沒提到，再來為大家統整一下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM：描述這個 Image 的基底，假設我們今天要做的專案是以 ruby 寫的，就可以設定為 ruby:alpine3.17 </span><br><span class="line">WORKDIR：建立一個資料夾，將需要的資料放到裡面，或者在其中執行指令 </span><br><span class="line">RUN：要執行的指令，就像是我們要跑一個 Rails 的專案，需要先 bundle </span><br><span class="line">COPY：複製前面的資料 到 後面的資料夾 ADD：加入檔案 CMD：預設的指令 </span><br><span class="line">EXPORT：對應到的 Port ENV：設定環境變數 </span><br><span class="line">ARG：設定變數(將應用在 build 過程中) </span><br><span class="line">LABEL：此 Image 的註解 </span><br><span class="line">VOLUME：指定 Container 的 Volume (通常會用來存放資料) ``` 當 Dockerfile 寫完後，我們就可以來把他打包成一顆 Image 了！ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker build -t  . </p><h1 id="t-為-Image-的-Tag-名稱"><a href="#t-為-Image-的-Tag-名稱" class="headerlink" title="-t 為 Image 的 Tag 名稱"></a>-t 為 Image 的 Tag 名稱</h1><p>#最後面的 . 是要告訴 Docker 你現在在哪兒 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">想要更改 Tag 名稱的時候 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker image tag ruby:latest ruby:Ning </p><h1 id="為了使用上方便，可以把-Image-修正為自己慣用的格式"><a href="#為了使用上方便，可以把-Image-修正為自己慣用的格式" class="headerlink" title="為了使用上方便，可以把 Image 修正為自己慣用的格式"></a>為了使用上方便，可以把 Image 修正為自己慣用的格式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">建立好 Image 後，就可以來跑 Container </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker container run -d -p 3000:3000  </p><h1 id="d-為背景執行的意思-p-為要將-Port-指到哪"><a href="#d-為背景執行的意思-p-為要將-Port-指到哪" class="headerlink" title="-d 為背景執行的意思 # -p 為要將 Port 指到哪"></a>-d 為背景執行的意思 # -p 為要將 Port 指到哪</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">停止 Container </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker container stop  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移除 Container </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker container rm  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移除 Image </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker image rm  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看 Image 歷史紀錄 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker image history  </p><h1 id="顯示出-Image-每層-Layer，就像-Dockerhub-中的-Layer"><a href="#顯示出-Image-每層-Layer，就像-Dockerhub-中的-Layer" class="headerlink" title="顯示出 Image 每層 Layer，就像 Dockerhub 中的 Layer"></a>顯示出 Image 每層 Layer，就像 Dockerhub 中的 Layer</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看 Image 的 Metadata </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ docker image inspect  </p><h1 id="確認-Image-中的基本資訊"><a href="#確認-Image-中的基本資訊" class="headerlink" title="確認 Image 中的基本資訊"></a>確認 Image 中的基本資訊</h1><pre><code>以上是基本的 Image 及 Container 常用指令 Docker 的指令非常多，所以想要學好 Docker 就要常常來練習～</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我們在先前文章提過，Dockerfile 是我們用來建立 Image 的檔案 &lt;/p&gt;
&lt;p&gt;我們可以把 Dockerfile 想像成是千層蛋糕 每一層為一個 Layer Image 就是層層堆疊後的千層蛋糕 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgu</summary>
      
    
    
    
    <category term="Docker" scheme="http://ninglab.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - 一起探索大鯨魚的奧妙</title>
    <link href="http://ninglab.com/Docker-docker-introduce/"/>
    <id>http://ninglab.com/Docker-docker-introduce/</id>
    <published>2024-02-22T15:00:54.000Z</published>
    <updated>2024-02-23T17:46:20.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="為什麼要用-Docker"><a href="#為什麼要用-Docker" class="headerlink" title="為什麼要用 Docker"></a>為什麼要用 Docker</h2><p>不曉得大家是不是常遇到要開啟一個專案，卻因為裝置不相容，在安裝的過程中要一直 debug 的狀況，有時候甚至架不起來？</p><p>Docker 就是為了解決這個問題而出現的</p><h2 id="什麼是-Docker"><a href="#什麼是-Docker" class="headerlink" title="什麼是 Docker"></a>什麼是 Docker</h2><p>Docker 是一種架設出虛擬環境的工具，我們可以透過 Docker 將應用程式單獨切分出來，並且用容器包裝成一個虛擬環境，並且載入你本機沒有但專案會需要的工具或版本，讓應用程式在虛擬環境中開發、執行</p><h2 id="學-Docker-必須要知道的幾個基本名詞"><a href="#學-Docker-必須要知道的幾個基本名詞" class="headerlink" title="學 Docker 必須要知道的幾個基本名詞"></a>學 Docker 必須要知道的幾個基本名詞</h2><ul><li><p>container：容器<br>  映像檔的具體化，通常一個專案會用一個以上的 container<br>(可能 1 個專案開 1 個 container 或者<br>資料庫 1 個 container 專案 1 個 container)<br>  Docker 會去開啟主機並監聽訊息，並把這個訊息傳給 container</p></li><li><p>image：映像檔<br>  唯讀，由 layer 建構而成</p></li><li><p>volume：<br>  在容器外運行，可連接不同的 container</p></li><li><p>daemon：<br>  管理 Docker image、開啟跟關閉 container</p></li><li><p>Docker Hub：<br>  類似 GitHub 的概念，是 image 的倉庫，可從上面拉取所需要的 image (權限可以設定為私有，只限定有權限的人才可以拉取)</p></li></ul><h2 id="更多-Docker-的專有名詞"><a href="#更多-Docker-的專有名詞" class="headerlink" title="更多 Docker 的專有名詞"></a>更多 Docker 的專有名詞</h2><p>在介紹 Docker 運作方式之前，我們需要了解更多專有名詞：</p><ul><li><p>Docker Engine：<br>  Docker 的核心，負責管理 image。<br>  包括 Docker Daemon、Docker API 和CLI。<br>  在建立 image 時，如果本地沒有相同 image，會從 Docker Hub 拉取。</p></li><li><p>Docker API：</p><p>  使用 RESTful 標準向 Docker Daemon發送請求。</p></li><li><p>Docker CLI：</p><p>  我們可以在這個介面下指令，並通過 Docker API 向 Docker Engine 發出指令。</p></li></ul><h2 id="Docker-運作流程"><a href="#Docker-運作流程" class="headerlink" title="Docker 運作流程"></a>Docker 運作流程</h2><p>我們可以將 Docker 想像成電腦中的一個盒子，在這個盒子內部有一個容器化的環境。</p><p>Docker 使用電腦的 CPU、記憶體和操作系統來運行。</p><p>為了更清楚地理解這個概念，請參考下面的圖表：<br><img src="https://i.imgur.com/JMyuMf2.jpg"></p><p>有這個基礎概念後，我們就來看一下當建立 image 時， Docker 是怎麼運作的</p><p><img src="https://imgur.com/RxbBMNF.jpg"></p><p>當我們下指令 <code>docker build -t xxxx .</code> 時，運作流程會是這樣：</p><ol><li>在 CLI 中輸入指令。</li><li>CLI 發送給 Docker API。</li><li>Docker API 以 RESTful 標準發送請求給 Docker daemon 去尋找 image。</li><li>如果本地找不到 image，會從 Docker Hub 下載 image。</li><li>建立 image。</li></ol><p>如果沒有錯誤或缺少套件，容器就可以成功建立。</p><p>image 建立起來後，還需要下指令才能讓他建立及運作 container<br>這時候會使用電腦中的 CPU、記憶體以及作業系統</p><ol start="6"><li>在 CLI 輸入 <code>docker container run xxxx .</code></li><li>container 開始運作</li></ol><p>如果要停止 container</p><ol start="8"><li>在 CLI 輸入 <code>docker container stop xxxx</code></li></ol><p>這時候 container 就會停止，而原本佔用電腦中的資源都會被釋放。</p><p>現在我們對 Docker 的基本概念有深度理解，下一篇文章將會比較著重在實際練習！</p><h2 id="English-Version"><a href="#English-Version" class="headerlink" title="English Version"></a>English Version</h2><h2 id="Why-use-Docker"><a href="#Why-use-Docker" class="headerlink" title="Why use Docker?"></a>Why use Docker?</h2><p>In certain situations, starting up a web server failed due to device incompatibility.</p><p>There are multiple steps involved in resolving the issue, and it can be challenging for developers to overcome these obstacles.</p><p>Integrating Docker into the project can avoid these awkward situations.</p><p>Docker simplifies the development and maintenance process for developers.</p><h2 id="What-is-Docker"><a href="#What-is-Docker" class="headerlink" title="What is Docker"></a>What is Docker</h2><p>Docker creates a virtual environment that contains services or applications.<br>This environment is separated from your computer and other containers built from the Docker images.</p><p>Based on the above explanation, an application can be started up and developed within the virtual environment, which provides the necessary dependencies version and tool.</p><h2 id="Basic-terminology-docker-beginners-have-to-learn"><a href="#Basic-terminology-docker-beginners-have-to-learn" class="headerlink" title="Basic terminology docker beginners have to learn"></a>Basic terminology docker beginners have to learn</h2><ul><li><p>container:<br>  Created from an image, it represents an instance of that image.<br>  A project typically usually consists of multiple containers.<br>  (Probably one project only has one container, it’s depending on the number of Dockerfiles)</p></li><li><p>image<br>  Immutable and consists of layers</p></li><li><p>Volume<br>  Exists outside the container, and allows for connection between different containers.</p></li><li><p>daemon<br>  Manage Docker images, starts and stops containers.</p></li><li><p>Docker Hub<br>  Similar to GitHub, is a platform to used to store images that anyone can pull image here.</p></li></ul><h3 id="Additional-Docker-terminology-you-should-know"><a href="#Additional-Docker-terminology-you-should-know" class="headerlink" title="Additional Docker terminology you should know"></a>Additional Docker terminology you should know</h3><p>Before we mention how docker works, it’s essential to understand a few more terms:</p><ul><li><p>Docker Engine:<br>  The Core of Docker management, it’s responsible for managing images.<br>  It includes Docker daemon, Docker API, and CLI.<br>  It will pull down images from Docker Hub if the same image is not found locally when we build an image.</p></li><li><p>Docker API<br>  Sends requests to Docker daemon using Restful standards.</p></li><li><p>Docker CLI<br>  An interface we can command to Docker Engine via Docker API.</p></li></ul><h2 id="How-does-Docker-operate"><a href="#How-does-Docker-operate" class="headerlink" title="How does Docker operate?"></a>How does Docker operate?</h2><p>We can image docker as a box within computers, there is a containerized environment inside the box, which has its hostname, IP address, and disk for data storage.<br>Docker uses the CPU, memory, and operating system resources of the device to run containers.</p><p>To clarify the concept, refer to the picture below.</p><p><img src="https://imgur.com/JMyuMf2.jpg"></p><p>So far, we have understood the fundamental concept of Docker, the important point of concept we will introduce in the chapter:</p><p><img src="https://imgur.com/RxbBMNF.jpg"></p><p>When we run <code>docker build -t xxxx .</code> in the beginning, Docker process follows these steps:</p><ol><li>We enter a command in the CLI.</li><li>The CLI sends a message to Docker API.</li><li>Docker API requests Docker Daemon to find the image by Restful standards.</li><li>Pull the image from Docker Hub if the same image is not available locally.</li><li>A image is built.</li></ol><p>Once these steps are completed without errors or missing dependencies, the container is successfully created.</p><p>The steps mentioned above only build a image, but it’s not building and running container. To do these, follow these steps:</p><ol start="6"><li>Enter <code>docker container run xxxx</code></li><li>Container will run successfully without errors.</li></ol><p>Docker accesses CPU, memory, and operating system resources from the computer when a container is running.</p><p>If we want to stop the container:</p><ol start="8"><li>Enter <code>docker container stop xxxx</code></li></ol><p>The resources container used will be released when stopping the container.</p><p>Now We have a solid understanding of the basic Docker concepts,  the next article will focus on practical exercises, see u soon.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;為什麼要用-Docker&quot;&gt;&lt;a href=&quot;#為什麼要用-Docker&quot; class=&quot;headerlink&quot; title=&quot;為什麼要用 Docker&quot;&gt;&lt;/a&gt;為什麼要用 Docker&lt;/h2&gt;&lt;p&gt;不曉得大家是不是常遇到要開啟一個專案，卻因為裝置不相容，在安</summary>
      
    
    
    
    <category term="Docker" scheme="http://ninglab.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Basic - 環境變數</title>
    <link href="http://ninglab.com/Basic-environment-variable/"/>
    <id>http://ninglab.com/Basic-environment-variable/</id>
    <published>2024-02-22T15:00:10.000Z</published>
    <updated>2024-02-23T17:46:14.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什麼是環境變數？"><a href="#什麼是環境變數？" class="headerlink" title="什麼是環境變數？"></a>什麼是環境變數？</h2><p>在我們開始之前，讓我們先了解環境是什麼 </p><h3 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h3><p>環境是指 operating system 或 microservice，例如我們常用的終端機。 </p><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>在任何程式語言中，我們有兩個基本元素：常數和變數 他被會由一個 key 跟 value 配對而成 </p><p>常數：在執行期間不會被改變及重新定義（不過在某些語言中可能會被改變）<br>變數：在執行期間更改和重新定義 常數和變數在記憶體空間會被配專屬的位置 </p><h3 id="何時使用環境變數？"><a href="#何時使用環境變數？" class="headerlink" title="何時使用環境變數？"></a>何時使用環境變數？</h3><p>每個環境中都會有預設的環境變數 通常用於存放服務的用戶名及密碼、API路徑和其他機密資料<br>application 在初始化期間載入這些環境變數<br>在運行期間，key 會被替換為對應的 value，我們就可以輕鬆且安全地使用服務 </p><h3 id="如何使用環境變數？"><a href="#如何使用環境變數？" class="headerlink" title="如何使用環境變數？"></a>如何使用環境變數？</h3><p>我們先來查看系統中已經存在的環境變數 </p><p>在終端機中下指令： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PATH</span><br></pre></td></tr></table></figure><p>顯示 PATH 環境變數的 value： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx/.rvm/gems/ruby-3.2.2/bin:xxx/.rvm/gems/ruby-3.2.2@global/bin:/xxx/.rvm/rubies/ruby-3.2.2/bin </span><br></pre></td></tr></table></figure><p>接下來，我們使用 export 來設置環境變數： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; export PASSWORD=password </span><br></pre></td></tr></table></figure><p>要顯示 PASSWORD 變數的值，我們一樣使用： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PASSWORD </span><br></pre></td></tr></table></figure><p>這樣我們就成功設定了自定義的環境變數 </p><p>接下來想額外分享一個指令 </p><p>我們可以針對特定的環境設定環境變數，用以下指令： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; PASSWORD=password irb </span><br></pre></td></tr></table></figure><p>在 irb 中查看我們剛剛設定的環境變數： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ENV[&quot;PASSWORD&quot;] # password </span><br></pre></td></tr></table></figure><h3 id="設定預設環境變數"><a href="#設定預設環境變數" class="headerlink" title="設定預設環境變數"></a>設定預設環境變數</h3><p>透過 export 或者在變數定義後加上特定的環境來設定環境變數，設定只能在當下的工作階段，一旦離開，就得重新設定環境變數。 </p><p>要確保環境變數存在於每個工作階段，我們需要在 .zshrc 或 .bashrc 檔案中進行配置。 </p><p>打開 zshrc 或 .bashrc 檔案（已有事先設定環境變數 EDITOR 為 code，還沒設定的話可以按照上個步驟去設定） </p><p>以 zshrc 為例， bashrc 也可以照做： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; code ~/.zshrc </span><br></pre></td></tr></table></figure><p>在 zshrc 檔案的最下面加環境變數並且儲存檔案： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; export PASSWORD=password </span><br></pre></td></tr></table></figure><p>接下來開一個新的終端機，並查看環境變數： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PASSWORD # password </span><br></pre></td></tr></table></figure><p>以上就完成設定了 </p><h3 id="在應用程序中設置環境變數"><a href="#在應用程序中設置環境變數" class="headerlink" title="在應用程序中設置環境變數"></a>在應用程序中設置環境變數</h3><p>在不影響系統的環境變數下，該怎麼針對個別應用程式設定環境變數，有些套件可以幫我們達成這件事 以 dotenv 為例，我們只需在 .env 文件中放置一組變數。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .env.development.local </span><br><span class="line"></span><br><span class="line"># service </span><br><span class="line">HOSTNAME=127.0.0.1:3000 </span><br></pre></td></tr></table></figure><p>在 application，我們可以使用這段程式碼來存取環境變數： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV[&quot;HOSTNAME&quot;] </span><br></pre></td></tr></table></figure><p>不過如果是要部署正式環境中，就必須要在各別環境中做設定，如何設定須取決於各個服務<br>之後會再介紹環境變數更詳細的內容 </p><h2 id="English-Version"><a href="#English-Version" class="headerlink" title="English Version"></a>English Version</h2><h2 id="What-is-environment-variable"><a href="#What-is-environment-variable" class="headerlink" title="What is environment variable?"></a>What is environment variable?</h2><p>Before we start, let’s understand the concept of environment.</p><p><img src="https://hackmd.io/_uploads/SyyEno5wn.jpg"></p><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>An Environment can refer to operating system or microservice, such as terminal that commonly used by developers, where commands can be executed.</p><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>In any computer programming language, there are two fundamental components, constants and variables.</p><p>they are defined by a pair of key and value.</p><p>Constants remain unchanged when programming executing.<br>(however, it may changed in some language if you go out of your way to modify setting)</p><p>Variables can be modified and reassigned during program execution.</p><p>Both represent unique locations stored data and value in memory.</p><h2 id="When-do-we-use-environment-variable"><a href="#When-do-we-use-environment-variable" class="headerlink" title="When do we use environment variable?"></a>When do we use environment variable?</h2><p>Environment variable are predefined in each environment.</p><p>They are commonly used to store user name and password of service, API paths, even sensitive data.</p><p>Application loaded these environment variables during initialization.</p><p>During runtime, the keys are replaced with current values, enable us to access service easily while ensuring security.</p><h2 id="How-do-we-use-them"><a href="#How-do-we-use-them" class="headerlink" title="How do we use them?"></a>How do we use them?</h2><p>First, let’s check environmant variable which already present in system.</p><p>use the following command in terminal:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PATH</span><br></pre></td></tr></table></figure><p>The value of PATH(environment variable) as shown below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx/.rvm/gems/ruby-3.2.2/bin:xxx/.rvm/gems/ruby-3.2.2@global/bin:/xxx/.rvm/rubies/ruby-3.2.2/bin</span><br></pre></td></tr></table></figure><p>Next, we use export command to set environment variable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; export PASSWORD=password</span><br></pre></td></tr></table></figure><p>It’s will display PASSWORD’s value when we use command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PASSWORD</span><br></pre></td></tr></table></figure><p>By doing so, we have successfully set up a custom environment variable.</p><p>But I want to share another command with you.</p><p>We can add environment after variable assignment, setting key-value pair within within a specific environment.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; PASSWORD=password irb</span><br></pre></td></tr></table></figure><p>once we enter the following command in irb, value will display.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ENV[&quot;PASSWORD&quot;]</span><br><span class="line"></span><br><span class="line"># password</span><br></pre></td></tr></table></figure><p>In the given situation, the steps are primarily for development purposes.</p><h2 id="Setting-default-environment-variable"><a href="#Setting-default-environment-variable" class="headerlink" title="Setting default environment variable"></a>Setting default environment variable</h2><p>We can set environment variable with command export or add specific environment after variable assignment, which only present in current session.</p><p>then, how to set default environment variable that persist in each session?</p><p>At beginning, we need to add environment variable in zshrc file or .bashrc</p><p>open .bashrc or .zshrc file (I have previously set <code>EDITOR</code> as key and paired with value code in environment, you can try to follow the instruction provided earlier to set environment variable)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; code ~/.zshrc</span><br></pre></td></tr></table></figure><p>put setting in the end of the file and save the file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; export PASSWORD=password</span><br></pre></td></tr></table></figure><p>Now, you can see the environment variable in every session</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo $PASSWORD</span><br></pre></td></tr></table></figure><h2 id="Set-environment-variable-in-application"><a href="#Set-environment-variable-in-application" class="headerlink" title="Set environment variable in application"></a>Set environment variable in application</h2><p>Package like dotenv can help us achieve the feature without affecting environment variable in system.</p><p>Using dotenv as an example, we can simply use it just put a bunch of variables in an <code>.env</code> file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .env.development.local</span><br><span class="line"></span><br><span class="line"># server</span><br><span class="line">HOSTNAME=127.0.0.1:3000</span><br></pre></td></tr></table></figure><p>In application, we can access environment variables using the code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV[&quot;HOSTNAME&quot;]</span><br></pre></td></tr></table></figure><p>If we want to deploy the application to a specific platform, we’ll need to make further settings.</p><p>We will introduce deeper concept of environment variable in the remaining article, see u soon.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什麼是環境變數？&quot;&gt;&lt;a href=&quot;#什麼是環境變數？&quot; class=&quot;headerlink&quot; title=&quot;什麼是環境變數？&quot;&gt;&lt;/a&gt;什麼是環境變數？&lt;/h2&gt;&lt;p&gt;在我們開始之前，讓我們先了解環境是什麼 &lt;/p&gt;
&lt;h3 id=&quot;環境&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="程式通識" scheme="http://ninglab.com/categories/%E7%A8%8B%E5%BC%8F%E9%80%9A%E8%AD%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Postgresql - JSONB 是什麼？跟 JSON 有什麼差別？</title>
    <link href="http://ninglab.com/Postgresql-different-between-json-and-jsonb/"/>
    <id>http://ninglab.com/Postgresql-different-between-json-and-jsonb/</id>
    <published>2024-02-22T14:52:07.000Z</published>
    <updated>2024-02-23T17:46:39.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jsonb-是什麼-PostgreSQL"><a href="#jsonb-是什麼-PostgreSQL" class="headerlink" title="jsonb 是什麼 PostgreSQL"></a>jsonb 是什麼 PostgreSQL</h2><p>支援的特有格式，而 b 指的是 binary ，因為 jsonb 是使用二進位來儲存格式 </p><h2 id="json-跟-jsonb-的差別"><a href="#json-跟-jsonb-的差別" class="headerlink" title="json 跟 jsonb 的差別"></a>json 跟 jsonb 的差別</h2><p><img src="https://hackmd.io/_uploads/SJTJ_rLI3.jpg"> </p><h4 id="什麼時候會用到"><a href="#什麼時候會用到" class="headerlink" title="什麼時候會用到"></a>什麼時候會用到</h4><p><img src="https://hackmd.io/_uploads/ByuyRSLU2.jpg"> </p><h2 id="在-rails-該怎麼使用"><a href="#在-rails-該怎麼使用" class="headerlink" title="在 rails 該怎麼使用"></a>在 rails 該怎麼使用</h2><ol><li>new 一個專案</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails new jsonb_0602 </span><br></pre></td></tr></table></figure><ol start="2"><li>gemfile 安裝 pg，並 bundle</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Gemfile </span><br><span class="line"></span><br><span class="line">gem &#x27;pg&#x27;, &#x27;~&gt; 1.1&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bundle </span><br></pre></td></tr></table></figure><ol start="3"><li>把 database.yml 改成 pg</li></ol><figure class="highlight plaintext"><figcaption><span>database.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">default: &amp;default </span><br><span class="line">adapter: postgresql </span><br><span class="line">pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt; </span><br><span class="line">timeout: 5000 </span><br><span class="line"></span><br><span class="line">development: &lt;&lt;: *default </span><br><span class="line">database: json_database </span><br><span class="line"></span><br><span class="line">test: &lt;&lt;: *default </span><br><span class="line">database: json_database </span><br><span class="line"></span><br><span class="line">production: &lt;&lt;: *default </span><br><span class="line">database: json_database </span><br></pre></td></tr></table></figure><ol start="4"><li>把資料庫建立起來</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails db:create </span><br></pre></td></tr></table></figure><ol start="5"><li>產生一個 model，例如發票 Receipt 設定其中一個欄位為 jsonb，例如發票資訊 <code>receipt_information</code> 設定完記得 migrate</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails g scaffold Receipt receipt_type:string receipt_information:jsonb </span><br><span class="line"></span><br><span class="line">&gt; rails db:migrate </span><br></pre></td></tr></table></figure><ol start="5"><li>啟動 server</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails s </span><br></pre></td></tr></table></figure><ol start="6"><li><p>到新增頁面 <code>http://127.0.0.1:3000/receipts/new</code> </p></li><li><p>修改新增頁面，在 receipt_information 使用 fields_for</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># app/views/receipts/new.html.erb </span><br><span class="line"># app/views/receipts/_form.html.erb </span><br><span class="line"></span><br><span class="line">&lt;%= form.label :receipt_information, style: &quot;display: block&quot; %&gt; </span><br><span class="line">&lt;%= form.fields_for :receipt_information do |note_form| %&gt; </span><br><span class="line">  &lt;%= note_form.text_field :gui_number, placeholder: &#x27;請輸入統編&#x27; %&gt; </span><br><span class="line">  &lt;%= note_form.text_field :company_name, placeholder: &#x27;請輸入公司名稱&#x27; %&gt; </span><br><span class="line">  &lt;%= note_form.text_field :address, placeholder: &#x27;請輸入公司地址&#x27; %&gt; </span><br><span class="line">&lt;% end %&gt; </span><br></pre></td></tr></table></figure><ol start="8"><li>params 清洗要這樣清洗</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def receipt_params </span><br><span class="line">  params.require(:receipt).permit(:receipt_type, receipt_information: [:gui_number, :company_name, :address]) </span><br><span class="line">end </span><br></pre></td></tr></table></figure><ol start="10"><li>到 console 確認資料</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails c</span><br><span class="line"></span><br><span class="line">3.2.2 :002 &gt; Receipt.last</span><br><span class="line">[#&lt;Receipt:0x000000010991dde0</span><br><span class="line">  id: 1,</span><br><span class="line">  receipt_type: &quot;triplicate_uniform_invoice&quot;,</span><br><span class="line">  receipt_information: &#123;&quot;gui_number&quot;=&gt;&quot;11111111&quot;, &quot;company_name&quot;=&gt;&quot;xxx&quot;, &quot;address&quot;=&gt;&quot;台北市中正區&quot;&#125;,</span><br><span class="line">  created_at: Thu, 01 Jun 2023 15:59:08.733933000 UTC +00:00,</span><br><span class="line">  updated_at: Thu, 01 Jun 2023 15:59:08.733933000 UTC +00:00&gt;]</span><br></pre></td></tr></table></figure><h2 id="資料成功存到資料庫了，但驗證呢？"><a href="#資料成功存到資料庫了，但驗證呢？" class="headerlink" title="資料成功存到資料庫了，但驗證呢？"></a>資料成功存到資料庫了，但驗證呢？</h2><ul><li>Rails 不支援 jsonb 的驗證<br><a href="https://github.com/voxpupuli/json-schema#ruby-json-schema-validator">Ruby JSON Schema Validator</a></li></ul><p>使用教學： </p><ol><li>安裝套件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Gemfile</span><br><span class="line"></span><br><span class="line">gem &#x27;json-schema&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>建立 schema，設定完重開 server</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># config/initializers/json_validator.rb</span><br><span class="line"></span><br><span class="line">RECEIPT_INFORMATION_SCHEMA = &#123;</span><br><span class="line">  type: &quot;object&quot;,</span><br><span class="line">  required: [</span><br><span class="line">      &quot;gui_number&quot;,</span><br><span class="line">      &quot;company_name&quot;,</span><br><span class="line">      &quot;address&quot;</span><br><span class="line">  ],</span><br><span class="line">  properties: &#123;</span><br><span class="line">      date: &#123;</span><br><span class="line">        type: &quot;string&quot;,</span><br><span class="line">        pattern: &quot;^[0-9]&#123;8&#125;$&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      company_name: &#123;</span><br><span class="line">        type: &quot;string&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      address: &#123;</span><br><span class="line">        type: &quot;string&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 model require 套件，並設定 validate 方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># app/models/receipt.rb</span><br><span class="line"></span><br><span class="line">class Receipt &lt; ApplicationRecord</span><br><span class="line">  require &quot;json-schema&quot;</span><br><span class="line"></span><br><span class="line">  before_validation :validate_information</span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  def validate_information</span><br><span class="line">    errors.add(:receipt, &quot;Invalid information format. Please enter a valid information format.&quot;) unless JSON::Validator.validate(RECEIPT_INFORMATION, receipt_information)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>台灣的統編有一定規則，並非純 8 個數字而已，上述僅供範例使用，若要嚴謹請另外找套件或者參考統編規則寫驗證</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jsonb-是什麼-PostgreSQL&quot;&gt;&lt;a href=&quot;#jsonb-是什麼-PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;jsonb 是什麼 PostgreSQL&quot;&gt;&lt;/a&gt;jsonb 是什麼 PostgreSQL&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="資料庫" scheme="http://ninglab.com/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL - 不管是交集還是聯集，JOIN 都能找到</title>
    <link href="http://ninglab.com/SQL-join/"/>
    <id>http://ninglab.com/SQL-join/</id>
    <published>2023-04-15T15:28:09.000Z</published>
    <updated>2024-02-23T17:47:01.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h1><p>上一篇我們介紹了 includes 跟 joins 的差異，今天想介紹一下 Joins 的各式用法及不同</p><p>先來假設我們今天有兩個 TABLE1 跟 TABLE2</p><p>TABLE1 存放了 學生的資料(table name &#x3D; Student)</p><table><thead><tr><th>id</th><th>name</th><th>phone</th><th>email</th><th>course_id</th></tr></thead><tbody><tr><td>1</td><td>Ning</td><td>0911123456</td><td><a href="mailto:&#110;&#105;&#x6e;&#103;&#x40;&#122;&#x7a;&#x2e;&#x7a;&#x7a;">&#110;&#105;&#x6e;&#103;&#x40;&#122;&#x7a;&#x2e;&#x7a;&#x7a;</a></td><td>1</td></tr><tr><td>2</td><td>Amy</td><td>0922123789</td><td><a href="mailto:&#97;&#109;&#x79;&#64;&#122;&#x7a;&#46;&#122;&#122;">&#97;&#109;&#x79;&#64;&#122;&#x7a;&#46;&#122;&#122;</a></td><td>2</td></tr><tr><td>3</td><td>Jason</td><td>0933456789</td><td><a href="mailto:&#x6a;&#x61;&#x73;&#x6f;&#110;&#x40;&#122;&#x7a;&#x2e;&#122;&#122;">&#x6a;&#x61;&#x73;&#x6f;&#110;&#x40;&#122;&#x7a;&#x2e;&#122;&#122;</a></td><td></td></tr></tbody></table><p>TABLE2 存放了 課程的資料(table name &#x3D; Course)</p><table><thead><tr><th>id</th><th>course</th><th>price</th><th>student_id</th></tr></thead><tbody><tr><td>1</td><td>english</td><td>150</td><td>1</td></tr><tr><td>2</td><td>japanese</td><td>150</td><td>2</td></tr><tr><td>3</td><td>french</td><td>150</td><td></td></tr></tbody></table><p>假設我們今天要看有哪個學生有買課程，我們來看一下各種 JOINS 的用法</p><h3 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h3><p><img src="https://i.imgur.com/7jr1fKs.jpg"></p><p>情境：今天要看有哪個學生有買課程<br>需求：要顯示的欄位只需要 <strong>有買課程的學生名字</strong> &#x2F; <strong>課程金額</strong></p><p>這時候我們就可以用 INNER JOINS 去搜尋</p><ul><li>可以把 INNER JOINS 想像成 Rails 的 Joins 方法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.id, TABLE1.name, TABLE2.price</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id;</span><br></pre></td></tr></table></figure><p>這邊解釋一下方法</p><ul><li>SELECT: 查詢的欄位</li><li>FROM: 以哪個資料庫為基準</li><li>ON: 放入篩選的條件，會根據這條件選出符合資格的資料</li></ul><p>最終會篩出這些資料</p><table><thead><tr><th>id</th><th>name</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>Ning</td><td>150</td></tr><tr><td>2</td><td>Amy</td><td>150</td></tr></tbody></table><h3 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h3><p><img src="https://i.imgur.com/4PfO6wI.jpg"></p><p>情境：今天要看有哪個學生有買課程，哪個學生沒買課程<br>需求：要顯示的欄位需要 <strong>所有學生的名字</strong> &#x2F; <strong>課程金額</strong></p><p>這時候我們就可以用 LEFT JOIN 方法，可以把 LEFT 想像成 FROM TABLE1 的 TABLE1，是以 TABLE1 的資料欄位為主，保留 TABLE1 的每一筆資料，並把 SELECT 要的共同資料(TABLE2 的 price)篩選出來</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.id, TABLE1.name, TABLE2.price</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br></pre></td></tr></table></figure><p>所以 LEFT JOIN 會幫我們選出這些資料</p><table><thead><tr><th>id</th><th>name</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>Ning</td><td>150</td></tr><tr><td>2</td><td>Amy</td><td>150</td></tr><tr><td>3</td><td>Jason</td><td></td></tr></tbody></table><h3 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h3><p><img src="https://i.imgur.com/09Yt3pl.jpg"></p><p>情境：哪個學生有買課程，也要看到哪些課程沒人買<br>需求：要顯示的欄位需要 <strong>有買課程的學生</strong> &#x2F; <strong>所有課程</strong></p><p>以 RIGHT JOIN 後面接的 TABLE2 為基準，保留 TABLE2 的每一筆資料，<br>並篩選出 SELECT 要的共同資料(TABLE1 的 name)篩選出來</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE2.id, TABLE2.course, TABLE2.price, TABLE1.name, </span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br></pre></td></tr></table></figure><p>所以會做出</p><table><thead><tr><th>id</th><th>course</th><th>price</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>english</td><td>150</td><td>Ning</td></tr><tr><td>2</td><td>japanese</td><td>150</td><td>Amy</td></tr><tr><td>3</td><td>french</td><td>150</td><td></td></tr></tbody></table><h3 id="FULL-OUTER-JOIN"><a href="#FULL-OUTER-JOIN" class="headerlink" title="FULL OUTER JOIN"></a>FULL OUTER JOIN</h3><p><img src="https://i.imgur.com/9z680N0.jpg"></p><p>情境：所有的學生跟所有課程的資料<br>需求：要顯示的欄位需要 <strong>所有學生名字</strong> &#x2F; <strong>所有課程資訊</strong></p><p>當兩個資料庫的資料都要全部保留的時候，並找出關聯時，就是 FULL OUTER JOIN 派上用場的時候了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.id, TABLE1.name, TABLE2.course, TABLE2.price</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br></pre></td></tr></table></figure><p>這時候就會做出</p><table><thead><tr><th>id</th><th>name</th><th>course</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>Ning</td><td>english</td><td>150</td></tr><tr><td>2</td><td>Amy</td><td>japanese</td><td>150</td></tr><tr><td>3</td><td>Jason</td><td></td><td></td></tr></tbody></table><p>以上是 JOIN 比較基本的語法介紹，接下來我們可以來點進階的</p><h3 id="LEFT-JOIN-without-data-from-table-2"><a href="#LEFT-JOIN-without-data-from-table-2" class="headerlink" title="LEFT JOIN without data from table 2"></a>LEFT JOIN without data from table 2</h3><p><img src="https://i.imgur.com/dHPCtRC.jpg"></p><p>情境：有哪個學生<strong>沒有買課程</strong><br>需求：要顯示的欄位需要 <strong>沒有買課程的學生名字</strong> &#x2F; <strong>沒有買課程的學生電話</strong></p><p>當我們需要的資料是沒有關聯的，並且只需要 TABLE1 (也就是 FROM 後面接的 TABLE)的資料時，就可以用 LEFT JOIN + WHERE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.id, TABLE1.name, TABLE1.phone</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br><span class="line"><span class="keyword">WHERE</span> TABLE2.student_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>就會跑出</p><table><thead><tr><th>id</th><th>name</th><th>phone</th></tr></thead><tbody><tr><td>3</td><td>Jason</td><td>0933456789</td></tr></tbody></table><h3 id="RIGHT-JOINS-without-data-from-table-1"><a href="#RIGHT-JOINS-without-data-from-table-1" class="headerlink" title="RIGHT JOINS without data from table 1"></a>RIGHT JOINS without data from table 1</h3><p><img src="https://i.imgur.com/XGGUfee.jpg"></p><p>情境：哪個課程<strong>沒有學生購買</strong><br>需求：要顯示的欄位需要 <strong>沒有學生購買的課程名稱</strong></p><p>用法與 LEFT JOIN without data from table 2 一樣</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE2.id, TABLE2.course</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br><span class="line"><span class="keyword">WHERE</span> TABLE1.course_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>這時候就會跑出</p><table><thead><tr><th>id</th><th>course</th></tr></thead><tbody><tr><td>3</td><td>french</td></tr></tbody></table><h3 id="FULL-OUTER-JOINS-without-data-from-table-1-and-2"><a href="#FULL-OUTER-JOINS-without-data-from-table-1-and-2" class="headerlink" title="FULL OUTER JOINS without data from table 1 and 2"></a>FULL OUTER JOINS without data from table 1 and 2</h3><p><img src="https://i.imgur.com/eFZMqEb.jpg"></p><p>情境：今天要看到<strong>哪個課程沒有學生購買</strong> 或者 <strong>哪個學生沒買課程</strong><br>需求：要顯示的欄位需要 <strong>沒買課程的學生名稱</strong> 及 <strong>沒學生購買的課程名稱</strong></p><p>尋找的條件就會使用 OR 來尋找，這些資料可以說是這兩個資料庫沒交集的資料群</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.name, TABLE2.course</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TABLE2</span><br><span class="line"><span class="keyword">ON</span> TABLE1.id <span class="operator">=</span> TABLE2.student_id</span><br><span class="line"><span class="keyword">WHERE</span> TABLE2.student_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">OR</span> TABLE1.course_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>所以就會找出</p><table><thead><tr><th>name</th><th>course</th></tr></thead><tbody><tr><td>Jason</td><td></td></tr><tr><td></td><td>french</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">學會 JOIN ，要找多難的集合資料都不是問題</summary>
    
    
    
    <category term="資料庫" scheme="http://ninglab.com/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL - Joins、Includes 差別在哪裡？</title>
    <link href="http://ninglab.com/SQL-different-between-joins-and-Includes/"/>
    <id>http://ninglab.com/SQL-different-between-joins-and-Includes/</id>
    <published>2023-04-08T15:19:24.000Z</published>
    <updated>2024-02-23T17:47:05.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Join-and-Includes"><a href="#Join-and-Includes" class="headerlink" title="Join and Includes"></a>Join and Includes</h1><p>我們在開發的時候免不了關聯資料庫，在撈資料的時候也常常會需要用到 joins 跟 includes</p><h2 id="所以，我們什麼時候會用到-joins-跟-includes"><a href="#所以，我們什麼時候會用到-joins-跟-includes" class="headerlink" title="所以，我們什麼時候會用到 joins 跟 includes"></a>所以，我們什麼時候會用到 joins 跟 includes</h2><ul><li>要尋找跟其他 model 有關聯的資料</li><li>避免 N + 1 問題</li></ul><p>** N + 1 問題是什麼呢？<br>當我們查詢多筆資料時，資料庫會先將所有的資料撈出，並一個一個去比對，就會有 N(筆資料) + 1(次撈出全部) 的問題存在</p><h2 id="joins-跟-includes-有什麼差別？"><a href="#joins-跟-includes-有什麼差別？" class="headerlink" title="joins 跟 includes 有什麼差別？"></a>joins 跟 includes 有什麼差別？</h2><p><img src="https://i.imgur.com/ZEftaXX.jpg"></p><p>joins 跟 includes 其實有蠻大的差別，</p><p>不過因為他們都是在查詢關聯資料，所以我們很常搞混，</p><p>不過搞懂他們的差別就會知道什麼時候該派誰上場。</p><p>** lazy loading：並不會一開始就載入所有資料，而是需要用到的時候才會去收集並載入<br>** eager loading：一開始就把需要的資料都載入，需要時就可以從 Cache 中拿取</p><p>先來說結論：joins 只會去比對資料，而 includes 會去查詢有關聯的資料，並存到 cache 中</p><p>那我們來看一下實際使用吧</p><h3 id="joins"><a href="#joins" class="headerlink" title="joins"></a>joins</h3><p>使用 joins 時，會去「比對」Tag 中有 post_id 的資料</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_tags = <span class="title class_">Post</span>.joins(<span class="symbol">:tags</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post Load (1.0ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; INNER JOIN &quot;tags&quot; ON &quot;tags&quot;.&quot;post_id&quot; = &quot;posts&quot;.&quot;id&quot; </span></span><br></pre></td></tr></table></figure><p>當我們需要這包資料時，<br>這時會再去資料庫撈一次資料，把有 tag 的資料撈出來呈現</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find_tags.each <span class="keyword">do</span> |<span class="params">post</span>|</span><br><span class="line">  p post.tags.first.name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tag Load (0.3ms)  SELECT &quot;tags&quot;.* FROM &quot;tags&quot; WHERE &quot;tags&quot;.&quot;post_id&quot; = $1 ORDER BY &quot;tags&quot;.&quot;id&quot; ASC LIMIT $2  [[&quot;post_id&quot;, 4], [&quot;LIMIT&quot;, 1]]</span></span><br><span class="line"><span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tag Load (0.1ms)  SELECT &quot;tags&quot;.* FROM &quot;tags&quot; WHERE &quot;tags&quot;.&quot;post_id&quot; = $1 ORDER BY &quot;tags&quot;.&quot;id&quot; ASC LIMIT $2  [[&quot;post_id&quot;, 7], [&quot;LIMIT&quot;, 1]]                                         </span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tag Load (0.1ms)  SELECT &quot;tags&quot;.* FROM &quot;tags&quot; WHERE &quot;tags&quot;.&quot;post_id&quot; = $1 ORDER BY &quot;tags&quot;.&quot;id&quot; ASC LIMIT $2  [[&quot;post_id&quot;, 8], [&quot;LIMIT&quot;, 1]]                                         </span></span><br><span class="line"><span class="number">3</span> </span><br></pre></td></tr></table></figure><p>看起來是不是很沒效率呢？<br>那我們來看看 includes 會怎麼運作</p><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>使用 includes 時，會去把所有 Tag 的資料一次撈出並查詢哪些有 post_id</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_tags = <span class="title class_">Post</span>.includes(<span class="symbol">:tags</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post Load (0.4ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; </span></span><br><span class="line"><span class="comment"># Tag Load (0.3ms)  SELECT &quot;tags&quot;.* FROM &quot;tags&quot; WHERE &quot;tags&quot;.&quot;post_id&quot; IN ($1, $2, $3, $4, $5, $6, $7, $8)  [[&quot;post_id&quot;, 3], [&quot;post_id&quot;, 4], [&quot;post_id&quot;, 7], [&quot;post_id&quot;, 8], [&quot;post_id&quot;, 9], [&quot;post_id&quot;, 2], [&quot;post_id&quot;, 1], [&quot;post_id&quot;, 10]] </span></span><br></pre></td></tr></table></figure><p>當我們需要使用這包資料時，<br>會直接從 Cache 中拿出這包已經處理好的資料</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_tags.each <span class="keyword">do</span> |<span class="params">post</span>|</span><br><span class="line">  p post.tags.first.name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>由上述例子可以知道， includes 在查詢及撈資料的過程都相對有效率</p><h2 id="所以用-includes-就比較好嗎？"><a href="#所以用-includes-就比較好嗎？" class="headerlink" title="所以用 includes 就比較好嗎？"></a>所以用 includes 就比較好嗎？</h2><p>要看使用的狀況，以剛剛的 Post 及 Tag 例子來看</p><p>我們改變一下需求，要撈出有 tag 的 post 資料，只需要呈現<strong>特定 tag 的 post 資訊</strong></p><h4 id="joins-1"><a href="#joins-1" class="headerlink" title="joins"></a>joins</h4><p>這時候 joins 只有去比對條件，並沒有去撈出資料</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find_tags = <span class="title class_">Post</span>.joins(<span class="symbol">:tags</span>).where(<span class="symbol">tag:</span> &#123;<span class="symbol">name:</span> <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Post Load (0.5ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; INNER JOIN &quot;tags&quot; ON &quot;tags&quot;.&quot;post_id&quot; = &quot;posts&quot;.&quot;id&quot; WHERE &quot;tags&quot;.&quot;tag_name&quot; = $1  [[&quot;tag_name&quot;, &quot;hello&quot;]]</span></span><br><span class="line"></span><br><span class="line">find_tags.each <span class="keyword">do</span> |<span class="params">post</span>|</span><br><span class="line">  p post.id</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="includes-1"><a href="#includes-1" class="headerlink" title="includes"></a>includes</h4><p>使用 includes ，會到資料庫將所有有關聯的資料撈出來做一次查詢</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find_tags = <span class="title class_">Post</span>.includes(<span class="symbol">:tags</span>).where(<span class="symbol">tag:</span> &#123;<span class="symbol">name:</span> <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL (1.0ms)  SELECT &quot;posts&quot;.&quot;id&quot; AS t0_r0, &quot;posts&quot;.&quot;title&quot; AS t0_r1, &quot;posts&quot;.&quot;description&quot; AS t0_r2, &quot;posts&quot;.&quot;content&quot; AS t0_r3, &quot;posts&quot;.&quot;created_at&quot; AS t0_r4, &quot;posts&quot;.&quot;updated_at&quot; AS t0_r5, &quot;posts&quot;.&quot;slug&quot; AS t0_r6, &quot;tags&quot;.&quot;id&quot; AS t1_r0, &quot;tags&quot;.&quot;tag_id&quot; AS t1_r1, &quot;tags&quot;.&quot;post_id&quot; AS t1_r2, &quot;tags&quot;.&quot;created_at&quot; AS t1_r3, &quot;tags&quot;.&quot;updated_at&quot; AS t1_r4 FROM &quot;posts&quot; LEFT OUTER JOIN &quot;tags&quot; ON &quot;tags&quot;.&quot;post_id&quot; = &quot;posts&quot;.&quot;id&quot; WHERE &quot;tags&quot;.&quot;tag_name&quot; = $1  [[&quot;tag_name&quot;, &quot;hello&quot;]] </span></span><br><span class="line"></span><br><span class="line">find_tags.each <span class="keyword">do</span> |<span class="params">post</span>|</span><br><span class="line">  p post.tags.first.name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>在不需要印出關聯資料庫的資料狀況時， joins 只有去比對資料，並沒有撈資料的動作，所以會比 includes 更有效率。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在查詢關聯資料時，joins 只會去比對資料，而 includes 則會去查詢有關聯的資料並存到 Cache 中。在實際使用中，joins 會比 includes 更加高效，特別是當我們不需要印出關聯資料時。</p>]]></content>
    
    
    <summary type="html">Joins 與 Includes 常常分不清楚，圖表化差別一次懂</summary>
    
    
    
    <category term="資料庫" scheme="http://ninglab.com/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - Dockerfile 基本介紹及指令</title>
    <link href="http://ninglab.com/Docker-Dockerfile-and-basic-command-1/"/>
    <id>http://ninglab.com/Docker-Dockerfile-and-basic-command-1/</id>
    <published>2023-03-20T18:04:56.000Z</published>
    <updated>2024-02-23T17:46:36.356Z</updated>
    
    <content type="html"><![CDATA[<p>我們在先前文章提過，Dockerfile 是我們用來建立 Image 的檔案</p><p>我們可以把 Dockerfile 想像成是千層蛋糕<br>每一層為一個 Layer<br>Image 就是層層堆疊後的千層蛋糕</p><p><img src="https://i.imgur.com/ZTNfcdt.jpg"></p><p>讓我們來看一下 DockerHub 裡的 Ruby</p><p>按到 Tags 頁籤，任意按一個版號進去，就會看到像是歷史紀錄的畫面，這就是 Dockerfile 跑出來的層層 Layer</p><p>到這邊應該還是難想像，我們來動手建立一個 Dockerfile 應該就會比較好理解</p><p><img src="https://i.imgur.com/GSspiC9.png"></p><p>我們來依序介紹 Dockerfile 的指令，並且邊按照下列步驟練習</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用什麼語言寫的，AS node 可以當作是貼上一個貼紙</span><br><span class="line">FROM node:14-alpine AS node</span><br><span class="line"></span><br><span class="line"># 稍後會需要 yarn install，所以先安裝 yarn</span><br><span class="line">RUN apk add --no-cache yarn</span><br><span class="line"></span><br><span class="line"># 建立資料夾，可放入我們需要的檔案，或者在此執行</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 複製 package.json 及 yarn.lock 到 /app 這個資料夾下</span><br><span class="line">COPY package.json yarn.lock /app/</span><br><span class="line"></span><br><span class="line"># 有 package.json 及 yarn.lock，就可以先把套件裝起來了！</span><br><span class="line">RUN yarn install</span><br><span class="line"></span><br><span class="line"># 套件安裝完畢，把所有檔案複製到 /app 中</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># 將 host 的 port 指向 Image 中 Node.js 的 port</span><br><span class="line">EXPOSE 9229:9229</span><br></pre></td></tr></table></figure><p>上面是針對一個由 Node.js 寫的專案建立的 Dockerfile<br>基本上就是把我們平常架起環境的步驟<br>只是會再切分的細一點</p><p>還有一些指令我們還沒提到，再來為大家統整一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM：描述這個 Image 的基底，假設我們今天要做的專案是以 ruby 寫的，就可以設定為 ruby:alpine3.17</span><br><span class="line">WORKDIR：建立一個資料夾，將需要的資料放到裡面，或者在其中執行指令</span><br><span class="line">RUN：要執行的指令，就像是我們要跑一個 Rails 的專案，需要先 bundle</span><br><span class="line">COPY：複製前面的資料 到 後面的資料夾</span><br><span class="line">ADD：加入檔案</span><br><span class="line">CMD：預設的指令</span><br><span class="line">EXPORT：對應到的 Port</span><br><span class="line">ENV：設定環境變數</span><br><span class="line">ARG：設定變數(將應用在 build 過程中)</span><br><span class="line">LABEL：此 Image 的註解</span><br><span class="line">VOLUME：指定 Container 的 Volume (通常會用來存放資料)</span><br></pre></td></tr></table></figure><p>當 Dockerfile 寫完後，我們就可以來把他打包成一顆 Image 了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;Image name&gt; .</span><br><span class="line"></span><br><span class="line"># -t 為 Image 的 Tag 名稱</span><br><span class="line">#最後面的 . 是要告訴 Docker 你現在在哪兒</span><br></pre></td></tr></table></figure><p>想要更改 Tag 名稱的時候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag ruby:latest ruby:Ning</span><br><span class="line"></span><br><span class="line"># 為了使用上方便，可以把 Image 修正為自己慣用的格式</span><br></pre></td></tr></table></figure><p>建立好 Image 後，就可以來跑 Container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d -p 3000:3000 &lt;Image name&gt;</span><br><span class="line"></span><br><span class="line"># -d 為背景執行的意思</span><br><span class="line"># -p 為要將 Port 指到哪</span><br></pre></td></tr></table></figure><p>停止 Container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop &lt;Container name or ID&gt;</span><br></pre></td></tr></table></figure><p>移除 Container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm &lt;Container name or ID&gt;</span><br></pre></td></tr></table></figure><p>移除 Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm &lt;Image name&gt;</span><br></pre></td></tr></table></figure><p>查看 Image 歷史紀錄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image history &lt;Image name&gt;</span><br><span class="line"></span><br><span class="line"># 顯示出 Image 每層 Layer，就像 Dockerhub 中的 Layer</span><br></pre></td></tr></table></figure><p>查看 Image 的 Metadata</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect &lt;Image name&gt;</span><br><span class="line"></span><br><span class="line"># 確認 Image 中的基本資訊</span><br></pre></td></tr></table></figure><p>以上是基本的 Image 及 Container 常用指令<br>Docker 的指令非常多，所以想要學好 Docker 就要常常來練習～</p>]]></content>
    
    
    <summary type="html">讓我們來一層層剝開像千層蛋糕般的 Dockerfile</summary>
    
    
    
    <category term="Docker" scheme="http://ninglab.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>工程師的日常 - 從測試開始 PART 1</title>
    <link href="http://ninglab.com/test-1/"/>
    <id>http://ninglab.com/test-1/</id>
    <published>2023-01-15T15:27:08.000Z</published>
    <updated>2024-02-23T17:45:15.836Z</updated>
    
    <content type="html"><![CDATA[<p>身為一個 Rails Developer<br>寫測試是必備的基本功</p><p>今天就來跟大家聊聊寫測試這件事</p><ul><li>什麼是測試？</li><li>為什麼要寫測試？</li><li>測試分成哪些類型</li><li>有哪些工具可以幫我們完成測試？</li><li>測試該從哪開始？</li><li>3A 原則</li></ul><h2 id="什麼是測試？"><a href="#什麼是測試？" class="headerlink" title="什麼是測試？"></a>什麼是測試？</h2><p>我們來看看維基百科怎麼定義。</p><blockquote><p>測試<br>  描述一種用來促進鑑定軟體的正確性、完整性、安全性和品質的過程。</p></blockquote><p>寫出簡單明瞭、完整符合需求的程式碼，應該是所有工程師的理想目標</p><p>寫測試可以幫助我們達成這個目標<br>當然寫測試的目的並不只有這個</p><h2 id="為什麼要寫測試？"><a href="#為什麼要寫測試？" class="headerlink" title="為什麼要寫測試？"></a>為什麼要寫測試？</h2><p>寫測試的好處多多；壞處，我想不太到</p><ol><li><p>有明確的規格可遵循開發<br> 客戶開出需求給我們，通常是範圍極大，或者沒有聚焦於重點的要求<br> 這時候要做的是將需求轉換為規格，讓我們跟客戶達成共識，有了規格，在日後的開發也會有一套標準能遵循，避免日後的爭議</p></li><li><p>了解程式的整個脈絡<br> 會將功能切分成好幾個小區塊，設想各種不同的情境，最後將整個情境串連起來，讓我們更能掌握整個程式碼運作的脈絡</p></li><li><p>保證程式碼能運作<br> 自動化測試能確保我們寫出來的程式在其他情境下是跑得動的</p></li><li><p>減少 bug 發生的機率<br> 經過不斷地修改、驗收測試，可預期使用者在流程中會遇到哪些 bug ，這些我們可以提前在測試中消除掉，且少了 bug 好處多多，有機會讓開發時程加速，以及重構應該也會更輕鬆哦！</p></li></ol><h2 id="測試分成哪些模式？"><a href="#測試分成哪些模式？" class="headerlink" title="測試分成哪些模式？"></a>測試分成哪些模式？</h2><ul><li>測試模式</li></ul><ol><li><p>單元測試<br> 將功能切分成一個個小單位，以不同的狀況及情境去測試，這時候的測試不會碰到資料庫的資料，可使用變數來進行測試。<br> 舉例來說，今天要測試 我買了一件商品後，剩下多少錢<br> 就可以用變數來完成這個測試</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">RSpec</span>.describe <span class="string">&#x27;purchase&#x27;</span>, <span class="symbol">type:</span> <span class="symbol">:feature</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&#x27;Calculate immediately after shopping&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#用變數定義及運算</span></span><br><span class="line">    my_money = <span class="number">100</span></span><br><span class="line">    milk = <span class="number">40</span></span><br><span class="line">      </span><br><span class="line">    available_balance = my_money - milk</span><br><span class="line">    </span><br><span class="line">    expect(available_balance).to be <span class="number">60</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rspec spec/features/test_spec.rb</span><br><span class="line"></span><br><span class="line">.Finished in 0.0106 seconds (files took 1.65 seconds to load)</span><br><span class="line">1 example, 0 failures</span><br></pre></td></tr></table></figure></li><li><p>整合測試<br> 是業界比較常寫到的測試，會需要針對資料庫或是外部系統去做資料的新增&#x2F;讀取&#x2F;修改&#x2F;刪除，假設我們今天要做記帳系統，要去測試 使用者每花一次錢，帳戶剩下多少</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">RSpec</span>.describe <span class="string">&#x27;purchase&#x27;</span>, <span class="symbol">type:</span> <span class="symbol">:feature</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&quot;Calculate user&#x27;s account immediately after shopping&quot;</span> <span class="keyword">do</span></span><br><span class="line">    account_balance = <span class="title class_">Account</span>.new(<span class="symbol">balance:</span> <span class="number">100</span>)&amp;.balance</span><br><span class="line">    milk_price = <span class="title class_">Product</span>.new(<span class="symbol">price:</span> <span class="number">40</span>)&amp;.price</span><br><span class="line">    </span><br><span class="line">    account_balance = account_balance - milk_price</span><br><span class="line">    </span><br><span class="line">    expect(account_balance).to be <span class="number">60</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rspec spec/features/test_spec.rb</span><br><span class="line"></span><br><span class="line">Finished in 0.0198 seconds (files took 0.94423 seconds to load)</span><br><span class="line">1 example, 0 failures</span><br></pre></td></tr></table></figure></li><li><p>系統測試<br> 測試整個應用程式的所有功能，會包含外部的系統(如金流系統)一起測試</p></li><li><p>使用者接受度測試<br> 應用程式是為了使用者的需求而寫出來的，好用與否也是使用者說的算，所以在上線前必須要先讓使用者測試</p></li></ol><h2 id="測試該從哪裡開始？"><a href="#測試該從哪裡開始？" class="headerlink" title="測試該從哪裡開始？"></a>測試該從哪裡開始？</h2><p>BDD 行動驅動開發</p><p>程式開發人員與測試人員一起將需求轉換成規格，<br>需要考量到不同的情境，規劃出不同的腳本，<br>並使用腳本進行測試及開發，<br>降低使用者及開發人員的資訊落差，<br>讓開發出來的功能符合使用者的需求。</p><p>TDD 測試驅動開發</p><p>當腳本完成後，就會開始進入測試流程，<br>不斷地測試、未通過、撰寫&#x2F;修改程式碼，直到最後通過。</p><h2 id="測試分成三大部分-3A-原則"><a href="#測試分成三大部分-3A-原則" class="headerlink" title="測試分成三大部分 3A 原則"></a>測試分成三大部分 3A 原則</h2><p>分別為 Arrange &#x2F; Act &#x2F; Assert，我們拿剛剛的買牛奶例子來解釋</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">RSpec</span>.describe <span class="string">&#x27;purchase&#x27;</span>, <span class="symbol">type:</span> <span class="symbol">:feature</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&#x27;Calculate immediately after shopping&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Arrange 安排，將要測試的資料都備齊</span></span><br><span class="line">    my_money = <span class="number">100</span></span><br><span class="line">    milk = <span class="number">40</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment"># Act 執行，撰寫方法並測試</span></span><br><span class="line">    available_balance = my_money - milk</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Assert 驗收，執行結果是否符合預期規格</span></span><br><span class="line">    expect(available_balance).to be <span class="number">60</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>測試通過也不能代表程式碼都是沒有問題的，<br>但是能盡量減少 bug 出現的機率，所以正確的開發流程必須包含測試。</p><p>如果開發完再補上測試，可能會有怎麼修都過不了的狀況(遇到會很痛ＱＱ)，<br>這代表程式碼並不符合規格，開發時間也會因此而延長。</p>]]></content>
    
    
    <summary type="html">搞定測試，開啟你的快樂開發之路</summary>
    
    
    
    <category term="測試" scheme="http://ninglab.com/categories/%E6%B8%AC%E8%A9%A6/"/>
    
    
  </entry>
  
</feed>
